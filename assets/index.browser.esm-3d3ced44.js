var ui=Object.defineProperty;var li=(s,e,t)=>e in s?ui(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var xe=(s,e,t)=>(li(s,typeof e!="symbol"?e+"":e,t),t);import{b6 as di,b7 as hi,b8 as fi,b9 as Xr,ba as gi,bb as pi,bc as yi,bd as H,be as bi,bf as Ls,a as Cs,g as Os,c as ct,d as q,bg as Ns,bh as dr,bi as Qr}from"./index-202a2435.js";import{b as mi,B as es}from"./bn-77a724e5.js";import{s as wi}from"./index-723e7c27.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const zs=BigInt(0),zn=BigInt(1),ki=BigInt(2);function zt(s){return s instanceof Uint8Array||s!=null&&typeof s=="object"&&s.constructor.name==="Uint8Array"}function gn(s){if(!zt(s))throw new Error("Uint8Array expected")}const Si=Array.from({length:256},(s,e)=>e.toString(16).padStart(2,"0"));function Ut(s){gn(s);let e="";for(let t=0;t<s.length;t++)e+=Si[s[t]];return e}function Us(s){const e=s.toString(16);return e.length&1?`0${e}`:e}function kr(s){if(typeof s!="string")throw new Error("hex string expected, got "+typeof s);return BigInt(s===""?"0":`0x${s}`)}const gt={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function ts(s){if(s>=gt._0&&s<=gt._9)return s-gt._0;if(s>=gt._A&&s<=gt._F)return s-(gt._A-10);if(s>=gt._a&&s<=gt._f)return s-(gt._a-10)}function Ht(s){if(typeof s!="string")throw new Error("hex string expected, got "+typeof s);const e=s.length,t=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(t);for(let r=0,o=0;r<t;r++,o+=2){const i=ts(s.charCodeAt(o)),a=ts(s.charCodeAt(o+1));if(i===void 0||a===void 0){const c=s[o]+s[o+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+o)}n[r]=i*16+a}return n}function Ot(s){return kr(Ut(s))}function Mt(s){return gn(s),kr(Ut(Uint8Array.from(s).reverse()))}function Vt(s,e){return Ht(s.toString(16).padStart(e*2,"0"))}function ln(s,e){return Vt(s,e).reverse()}function Ii(s){return Ht(Us(s))}function Be(s,e,t){let n;if(typeof e=="string")try{n=Ht(e)}catch(o){throw new Error(`${s} must be valid hex string, got "${e}". Cause: ${o}`)}else if(zt(e))n=Uint8Array.from(e);else throw new Error(`${s} must be hex string or Uint8Array`);const r=n.length;if(typeof t=="number"&&r!==t)throw new Error(`${s} expected ${t} bytes, got ${r}`);return n}function Kt(...s){let e=0;for(let n=0;n<s.length;n++){const r=s[n];gn(r),e+=r.length}const t=new Uint8Array(e);for(let n=0,r=0;n<s.length;n++){const o=s[n];t.set(o,r),r+=o.length}return t}function Ei(s,e){if(s.length!==e.length)return!1;let t=0;for(let n=0;n<s.length;n++)t|=s[n]^e[n];return t===0}function Ai(s){if(typeof s!="string")throw new Error(`utf8ToBytes expected string, got ${typeof s}`);return new Uint8Array(new TextEncoder().encode(s))}function _i(s){let e;for(e=0;s>zs;s>>=zn,e+=1);return e}function Bi(s,e){return s>>BigInt(e)&zn}function xi(s,e,t){return s|(t?zn:zs)<<BigInt(e)}const Sr=s=>(ki<<BigInt(s-1))-zn,Yn=s=>new Uint8Array(s),ns=s=>Uint8Array.from(s);function Ks(s,e,t){if(typeof s!="number"||s<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=Yn(s),r=Yn(s),o=0;const i=()=>{n.fill(1),r.fill(0),o=0},a=(...h)=>t(r,n,...h),c=(h=Yn())=>{r=a(ns([0]),h),n=a(),h.length!==0&&(r=a(ns([1]),h),n=a())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let h=0;const w=[];for(;h<e;){n=a();const p=n.slice();w.push(p),h+=n.length}return Kt(...w)};return(h,w)=>{i(),c(h);let p;for(;!(p=w(u()));)c();return i(),p}}const vi={bigint:s=>typeof s=="bigint",function:s=>typeof s=="function",boolean:s=>typeof s=="boolean",string:s=>typeof s=="string",stringOrUint8Array:s=>typeof s=="string"||zt(s),isSafeInteger:s=>Number.isSafeInteger(s),array:s=>Array.isArray(s),field:(s,e)=>e.Fp.isValid(s),hash:s=>typeof s=="function"&&Number.isSafeInteger(s.outputLen)};function Jt(s,e,t={}){const n=(r,o,i)=>{const a=vi[o];if(typeof a!="function")throw new Error(`Invalid validator "${o}", expected function`);const c=s[r];if(!(i&&c===void 0)&&!a(c,s))throw new Error(`Invalid param ${String(r)}=${c} (${typeof c}), expected ${o}`)};for(const[r,o]of Object.entries(e))n(r,o,!1);for(const[r,o]of Object.entries(t))n(r,o,!0);return s}const Ri=Object.freeze(Object.defineProperty({__proto__:null,abytes:gn,bitGet:Bi,bitLen:_i,bitMask:Sr,bitSet:xi,bytesToHex:Ut,bytesToNumberBE:Ot,bytesToNumberLE:Mt,concatBytes:Kt,createHmacDrbg:Ks,ensureBytes:Be,equalBytes:Ei,hexToBytes:Ht,hexToNumber:kr,isBytes:zt,numberToBytesBE:Vt,numberToBytesLE:ln,numberToHexUnpadded:Us,numberToVarBytesBE:Ii,utf8ToBytes:Ai,validateObject:Jt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ve=BigInt(0),be=BigInt(1),vt=BigInt(2),Pi=BigInt(3),hr=BigInt(4),rs=BigInt(5),ss=BigInt(8);BigInt(9);BigInt(16);function pe(s,e){const t=s%e;return t>=ve?t:e+t}function Ti(s,e,t){if(t<=ve||e<ve)throw new Error("Expected power/modulo > 0");if(t===be)return ve;let n=be;for(;e>ve;)e&be&&(n=n*s%t),s=s*s%t,e>>=be;return n}function ke(s,e,t){let n=s;for(;e-- >ve;)n*=n,n%=t;return n}function fr(s,e){if(s===ve||e<=ve)throw new Error(`invert: expected positive integers, got n=${s} mod=${e}`);let t=pe(s,e),n=e,r=ve,o=be;for(;t!==ve;){const a=n/t,c=n%t,u=r-o*a;n=t,t=c,r=o,o=u}if(n!==be)throw new Error("invert: does not exist");return pe(r,e)}function Li(s){const e=(s-be)/vt;let t,n,r;for(t=s-be,n=0;t%vt===ve;t/=vt,n++);for(r=vt;r<s&&Ti(r,e,s)!==s-be;r++);if(n===1){const i=(s+be)/hr;return function(c,u){const l=c.pow(u,i);if(!c.eql(c.sqr(l),u))throw new Error("Cannot find square root");return l}}const o=(t+be)/vt;return function(a,c){if(a.pow(c,e)===a.neg(a.ONE))throw new Error("Cannot find square root");let u=n,l=a.pow(a.mul(a.ONE,r),t),h=a.pow(c,o),w=a.pow(c,t);for(;!a.eql(w,a.ONE);){if(a.eql(w,a.ZERO))return a.ZERO;let p=1;for(let d=a.sqr(w);p<u&&!a.eql(d,a.ONE);p++)d=a.sqr(d);const y=a.pow(l,be<<BigInt(u-p-1));l=a.sqr(y),h=a.mul(h,y),w=a.mul(w,l),u=p}return h}}function Ci(s){if(s%hr===Pi){const e=(s+be)/hr;return function(n,r){const o=n.pow(r,e);if(!n.eql(n.sqr(o),r))throw new Error("Cannot find square root");return o}}if(s%ss===rs){const e=(s-rs)/ss;return function(n,r){const o=n.mul(r,vt),i=n.pow(o,e),a=n.mul(r,i),c=n.mul(n.mul(a,vt),i),u=n.mul(a,n.sub(c,n.ONE));if(!n.eql(n.sqr(u),r))throw new Error("Cannot find square root");return u}}return Li(s)}const Oi=(s,e)=>(pe(s,e)&be)===be,Ni=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function zi(s){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Ni.reduce((n,r)=>(n[r]="function",n),e);return Jt(s,t)}function Ui(s,e,t){if(t<ve)throw new Error("Expected power > 0");if(t===ve)return s.ONE;if(t===be)return e;let n=s.ONE,r=e;for(;t>ve;)t&be&&(n=s.mul(n,r)),r=s.sqr(r),t>>=be;return n}function Ki(s,e){const t=new Array(e.length),n=e.reduce((o,i,a)=>s.is0(i)?o:(t[a]=o,s.mul(o,i)),s.ONE),r=s.inv(n);return e.reduceRight((o,i,a)=>s.is0(i)?o:(t[a]=s.mul(o,t[a]),s.mul(o,i)),r),t}function Ws(s,e){const t=e!==void 0?e:s.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function Fs(s,e,t=!1,n={}){if(s<=ve)throw new Error(`Expected Field ORDER > 0, got ${s}`);const{nBitLength:r,nByteLength:o}=Ws(s,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const i=Ci(s),a=Object.freeze({ORDER:s,BITS:r,BYTES:o,MASK:Sr(r),ZERO:ve,ONE:be,create:c=>pe(c,s),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return ve<=c&&c<s},is0:c=>c===ve,isOdd:c=>(c&be)===be,neg:c=>pe(-c,s),eql:(c,u)=>c===u,sqr:c=>pe(c*c,s),add:(c,u)=>pe(c+u,s),sub:(c,u)=>pe(c-u,s),mul:(c,u)=>pe(c*u,s),pow:(c,u)=>Ui(a,c,u),div:(c,u)=>pe(c*fr(u,s),s),sqrN:c=>c*c,addN:(c,u)=>c+u,subN:(c,u)=>c-u,mulN:(c,u)=>c*u,inv:c=>fr(c,s),sqrt:n.sqrt||(c=>i(a,c)),invertBatch:c=>Ki(a,c),cmov:(c,u,l)=>l?u:c,toBytes:c=>t?ln(c,o):Vt(c,o),fromBytes:c=>{if(c.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${c.length}`);return t?Mt(c):Ot(c)}});return Object.freeze(a)}function Ds(s){if(typeof s!="bigint")throw new Error("field order must be bigint");const e=s.toString(2).length;return Math.ceil(e/8)}function qs(s){const e=Ds(s);return e+Math.ceil(e/2)}function Wi(s,e,t=!1){const n=s.length,r=Ds(e),o=qs(e);if(n<16||n<o||n>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${n}`);const i=t?Ot(s):Mt(s),a=pe(i,e-be)+be;return t?ln(a,r):Vt(a,r)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Fi=BigInt(0),Zn=BigInt(1);function $s(s,e){const t=(r,o)=>{const i=o.negate();return r?i:o},n=r=>{const o=Math.ceil(e/r)+1,i=2**(r-1);return{windows:o,windowSize:i}};return{constTimeNegate:t,unsafeLadder(r,o){let i=s.ZERO,a=r;for(;o>Fi;)o&Zn&&(i=i.add(a)),a=a.double(),o>>=Zn;return i},precomputeWindow(r,o){const{windows:i,windowSize:a}=n(o),c=[];let u=r,l=u;for(let h=0;h<i;h++){l=u,c.push(l);for(let w=1;w<a;w++)l=l.add(u),c.push(l);u=l.double()}return c},wNAF(r,o,i){const{windows:a,windowSize:c}=n(r);let u=s.ZERO,l=s.BASE;const h=BigInt(2**r-1),w=2**r,p=BigInt(r);for(let y=0;y<a;y++){const d=y*c;let f=Number(i&h);i>>=p,f>c&&(f-=w,i+=Zn);const m=d,E=d+Math.abs(f)-1,I=y%2!==0,C=f<0;f===0?l=l.add(t(I,o[m])):u=u.add(t(C,o[E]))}return{p:u,f:l}},wNAFCached(r,o,i,a){const c=r._WINDOW_SIZE||1;let u=o.get(r);return u||(u=this.precomputeWindow(r,c),c!==1&&o.set(r,a(u))),this.wNAF(c,u,i)}}}function Ir(s){return zi(s.Fp),Jt(s,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Ws(s.n,s.nBitLength),...s,p:s.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Di(s){const e=Ir(s);Jt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:n,a:r}=e;if(t){if(!n.eql(r,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:qi,hexToBytes:$i}=Ri,Lt={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(s){const{Err:e}=Lt;if(s.length<2||s[0]!==2)throw new e("Invalid signature integer tag");const t=s[1],n=s.subarray(2,t+2);if(!t||n.length!==t)throw new e("Invalid signature integer: wrong length");if(n[0]&128)throw new e("Invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:qi(n),l:s.subarray(t+2)}},toSig(s){const{Err:e}=Lt,t=typeof s=="string"?$i(s):s;gn(t);let n=t.length;if(n<2||t[0]!=48)throw new e("Invalid signature tag");if(t[1]!==n-2)throw new e("Invalid signature: incorrect length");const{d:r,l:o}=Lt._parseInt(t.subarray(2)),{d:i,l:a}=Lt._parseInt(o);if(a.length)throw new e("Invalid signature: left bytes after parsing");return{r,s:i}},hexFromSig(s){const e=u=>Number.parseInt(u[0],16)&8?"00"+u:u,t=u=>{const l=u.toString(16);return l.length&1?`0${l}`:l},n=e(t(s.s)),r=e(t(s.r)),o=n.length/2,i=r.length/2,a=t(o),c=t(i);return`30${t(i+o+4)}02${c}${r}02${a}${n}`}},yt=BigInt(0),Qe=BigInt(1);BigInt(2);const os=BigInt(3);BigInt(4);function Mi(s){const e=Di(s),{Fp:t}=e,n=e.toBytes||((y,d,f)=>{const m=d.toAffine();return Kt(Uint8Array.from([4]),t.toBytes(m.x),t.toBytes(m.y))}),r=e.fromBytes||(y=>{const d=y.subarray(1),f=t.fromBytes(d.subarray(0,t.BYTES)),m=t.fromBytes(d.subarray(t.BYTES,2*t.BYTES));return{x:f,y:m}});function o(y){const{a:d,b:f}=e,m=t.sqr(y),E=t.mul(m,y);return t.add(t.add(E,t.mul(y,d)),f)}if(!t.eql(t.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function i(y){return typeof y=="bigint"&&yt<y&&y<e.n}function a(y){if(!i(y))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(y){const{allowedPrivateKeyLengths:d,nByteLength:f,wrapPrivateKey:m,n:E}=e;if(d&&typeof y!="bigint"){if(zt(y)&&(y=Ut(y)),typeof y!="string"||!d.includes(y.length))throw new Error("Invalid key");y=y.padStart(f*2,"0")}let I;try{I=typeof y=="bigint"?y:Ot(Be("private key",y,f))}catch{throw new Error(`private key must be ${f} bytes, hex or bigint, not ${typeof y}`)}return m&&(I=pe(I,E)),a(I),I}const u=new Map;function l(y){if(!(y instanceof h))throw new Error("ProjectivePoint expected")}class h{constructor(d,f,m){if(this.px=d,this.py=f,this.pz=m,d==null||!t.isValid(d))throw new Error("x required");if(f==null||!t.isValid(f))throw new Error("y required");if(m==null||!t.isValid(m))throw new Error("z required")}static fromAffine(d){const{x:f,y:m}=d||{};if(!d||!t.isValid(f)||!t.isValid(m))throw new Error("invalid affine point");if(d instanceof h)throw new Error("projective point not allowed");const E=I=>t.eql(I,t.ZERO);return E(f)&&E(m)?h.ZERO:new h(f,m,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(d){const f=t.invertBatch(d.map(m=>m.pz));return d.map((m,E)=>m.toAffine(f[E])).map(h.fromAffine)}static fromHex(d){const f=h.fromAffine(r(Be("pointHex",d)));return f.assertValidity(),f}static fromPrivateKey(d){return h.BASE.multiply(c(d))}_setWindowSize(d){this._WINDOW_SIZE=d,u.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!t.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:d,y:f}=this.toAffine();if(!t.isValid(d)||!t.isValid(f))throw new Error("bad point: x or y not FE");const m=t.sqr(f),E=o(d);if(!t.eql(m,E))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:d}=this.toAffine();if(t.isOdd)return!t.isOdd(d);throw new Error("Field doesn't support isOdd")}equals(d){l(d);const{px:f,py:m,pz:E}=this,{px:I,py:C,pz:_}=d,L=t.eql(t.mul(f,_),t.mul(I,E)),K=t.eql(t.mul(m,_),t.mul(C,E));return L&&K}negate(){return new h(this.px,t.neg(this.py),this.pz)}double(){const{a:d,b:f}=e,m=t.mul(f,os),{px:E,py:I,pz:C}=this;let _=t.ZERO,L=t.ZERO,K=t.ZERO,F=t.mul(E,E),he=t.mul(I,I),ne=t.mul(C,C),G=t.mul(E,I);return G=t.add(G,G),K=t.mul(E,C),K=t.add(K,K),_=t.mul(d,K),L=t.mul(m,ne),L=t.add(_,L),_=t.sub(he,L),L=t.add(he,L),L=t.mul(_,L),_=t.mul(G,_),K=t.mul(m,K),ne=t.mul(d,ne),G=t.sub(F,ne),G=t.mul(d,G),G=t.add(G,K),K=t.add(F,F),F=t.add(K,F),F=t.add(F,ne),F=t.mul(F,G),L=t.add(L,F),ne=t.mul(I,C),ne=t.add(ne,ne),F=t.mul(ne,G),_=t.sub(_,F),K=t.mul(ne,he),K=t.add(K,K),K=t.add(K,K),new h(_,L,K)}add(d){l(d);const{px:f,py:m,pz:E}=this,{px:I,py:C,pz:_}=d;let L=t.ZERO,K=t.ZERO,F=t.ZERO;const he=e.a,ne=t.mul(e.b,os);let G=t.mul(f,I),Ae=t.mul(m,C),Ie=t.mul(E,_),Xe=t.add(f,m),v=t.add(I,C);Xe=t.mul(Xe,v),v=t.add(G,Ae),Xe=t.sub(Xe,v),v=t.add(f,E);let U=t.add(I,_);return v=t.mul(v,U),U=t.add(G,Ie),v=t.sub(v,U),U=t.add(m,E),L=t.add(C,_),U=t.mul(U,L),L=t.add(Ae,Ie),U=t.sub(U,L),F=t.mul(he,v),L=t.mul(ne,Ie),F=t.add(L,F),L=t.sub(Ae,F),F=t.add(Ae,F),K=t.mul(L,F),Ae=t.add(G,G),Ae=t.add(Ae,G),Ie=t.mul(he,Ie),v=t.mul(ne,v),Ae=t.add(Ae,Ie),Ie=t.sub(G,Ie),Ie=t.mul(he,Ie),v=t.add(v,Ie),G=t.mul(Ae,v),K=t.add(K,G),G=t.mul(U,v),L=t.mul(Xe,L),L=t.sub(L,G),G=t.mul(Xe,Ae),F=t.mul(U,F),F=t.add(F,G),new h(L,K,F)}subtract(d){return this.add(d.negate())}is0(){return this.equals(h.ZERO)}wNAF(d){return p.wNAFCached(this,u,d,f=>{const m=t.invertBatch(f.map(E=>E.pz));return f.map((E,I)=>E.toAffine(m[I])).map(h.fromAffine)})}multiplyUnsafe(d){const f=h.ZERO;if(d===yt)return f;if(a(d),d===Qe)return this;const{endo:m}=e;if(!m)return p.unsafeLadder(this,d);let{k1neg:E,k1:I,k2neg:C,k2:_}=m.splitScalar(d),L=f,K=f,F=this;for(;I>yt||_>yt;)I&Qe&&(L=L.add(F)),_&Qe&&(K=K.add(F)),F=F.double(),I>>=Qe,_>>=Qe;return E&&(L=L.negate()),C&&(K=K.negate()),K=new h(t.mul(K.px,m.beta),K.py,K.pz),L.add(K)}multiply(d){a(d);let f=d,m,E;const{endo:I}=e;if(I){const{k1neg:C,k1:_,k2neg:L,k2:K}=I.splitScalar(f);let{p:F,f:he}=this.wNAF(_),{p:ne,f:G}=this.wNAF(K);F=p.constTimeNegate(C,F),ne=p.constTimeNegate(L,ne),ne=new h(t.mul(ne.px,I.beta),ne.py,ne.pz),m=F.add(ne),E=he.add(G)}else{const{p:C,f:_}=this.wNAF(f);m=C,E=_}return h.normalizeZ([m,E])[0]}multiplyAndAddUnsafe(d,f,m){const E=h.BASE,I=(_,L)=>L===yt||L===Qe||!_.equals(E)?_.multiplyUnsafe(L):_.multiply(L),C=I(this,f).add(I(d,m));return C.is0()?void 0:C}toAffine(d){const{px:f,py:m,pz:E}=this,I=this.is0();d==null&&(d=I?t.ONE:t.inv(E));const C=t.mul(f,d),_=t.mul(m,d),L=t.mul(E,d);if(I)return{x:t.ZERO,y:t.ZERO};if(!t.eql(L,t.ONE))throw new Error("invZ was invalid");return{x:C,y:_}}isTorsionFree(){const{h:d,isTorsionFree:f}=e;if(d===Qe)return!0;if(f)return f(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:d,clearCofactor:f}=e;return d===Qe?this:f?f(h,this):this.multiplyUnsafe(e.h)}toRawBytes(d=!0){return this.assertValidity(),n(h,this,d)}toHex(d=!0){return Ut(this.toRawBytes(d))}}h.BASE=new h(e.Gx,e.Gy,t.ONE),h.ZERO=new h(t.ZERO,t.ONE,t.ZERO);const w=e.nBitLength,p=$s(h,e.endo?Math.ceil(w/2):w);return{CURVE:e,ProjectivePoint:h,normPrivateKeyToScalar:c,weierstrassEquation:o,isWithinCurveOrder:i}}function Hi(s){const e=Ir(s);return Jt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Vi(s){const e=Hi(s),{Fp:t,n}=e,r=t.BYTES+1,o=2*t.BYTES+1;function i(v){return yt<v&&v<t.ORDER}function a(v){return pe(v,n)}function c(v){return fr(v,n)}const{ProjectivePoint:u,normPrivateKeyToScalar:l,weierstrassEquation:h,isWithinCurveOrder:w}=Mi({...e,toBytes(v,U,Y){const R=U.toAffine(),k=t.toBytes(R.x),O=Kt;return Y?O(Uint8Array.from([U.hasEvenY()?2:3]),k):O(Uint8Array.from([4]),k,t.toBytes(R.y))},fromBytes(v){const U=v.length,Y=v[0],R=v.subarray(1);if(U===r&&(Y===2||Y===3)){const k=Ot(R);if(!i(k))throw new Error("Point is not on curve");const O=h(k);let D;try{D=t.sqrt(O)}catch(J){const ie=J instanceof Error?": "+J.message:"";throw new Error("Point is not on curve"+ie)}const M=(D&Qe)===Qe;return(Y&1)===1!==M&&(D=t.neg(D)),{x:k,y:D}}else if(U===o&&Y===4){const k=t.fromBytes(R.subarray(0,t.BYTES)),O=t.fromBytes(R.subarray(t.BYTES,2*t.BYTES));return{x:k,y:O}}else throw new Error(`Point of length ${U} was invalid. Expected ${r} compressed bytes or ${o} uncompressed bytes`)}}),p=v=>Ut(Vt(v,e.nByteLength));function y(v){const U=n>>Qe;return v>U}function d(v){return y(v)?a(-v):v}const f=(v,U,Y)=>Ot(v.slice(U,Y));class m{constructor(U,Y,R){this.r=U,this.s=Y,this.recovery=R,this.assertValidity()}static fromCompact(U){const Y=e.nByteLength;return U=Be("compactSignature",U,Y*2),new m(f(U,0,Y),f(U,Y,2*Y))}static fromDER(U){const{r:Y,s:R}=Lt.toSig(Be("DER",U));return new m(Y,R)}assertValidity(){if(!w(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!w(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(U){return new m(this.r,this.s,U)}recoverPublicKey(U){const{r:Y,s:R,recovery:k}=this,O=K(Be("msgHash",U));if(k==null||![0,1,2,3].includes(k))throw new Error("recovery id invalid");const D=k===2||k===3?Y+e.n:Y;if(D>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const M=k&1?"03":"02",Z=u.fromHex(M+p(D)),J=c(D),ie=a(-O*J),Q=a(R*J),re=u.BASE.multiplyAndAddUnsafe(Z,ie,Q);if(!re)throw new Error("point at infinify");return re.assertValidity(),re}hasHighS(){return y(this.s)}normalizeS(){return this.hasHighS()?new m(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return Ht(this.toDERHex())}toDERHex(){return Lt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Ht(this.toCompactHex())}toCompactHex(){return p(this.r)+p(this.s)}}const E={isValidPrivateKey(v){try{return l(v),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const v=qs(e.n);return Wi(e.randomBytes(v),e.n)},precompute(v=8,U=u.BASE){return U._setWindowSize(v),U.multiply(BigInt(3)),U}};function I(v,U=!0){return u.fromPrivateKey(v).toRawBytes(U)}function C(v){const U=zt(v),Y=typeof v=="string",R=(U||Y)&&v.length;return U?R===r||R===o:Y?R===2*r||R===2*o:v instanceof u}function _(v,U,Y=!0){if(C(v))throw new Error("first arg must be private key");if(!C(U))throw new Error("second arg must be public key");return u.fromHex(U).multiply(l(v)).toRawBytes(Y)}const L=e.bits2int||function(v){const U=Ot(v),Y=v.length*8-e.nBitLength;return Y>0?U>>BigInt(Y):U},K=e.bits2int_modN||function(v){return a(L(v))},F=Sr(e.nBitLength);function he(v){if(typeof v!="bigint")throw new Error("bigint expected");if(!(yt<=v&&v<F))throw new Error(`bigint expected < 2^${e.nBitLength}`);return Vt(v,e.nByteLength)}function ne(v,U,Y=G){if(["recovered","canonical"].some(we=>we in Y))throw new Error("sign() legacy options not supported");const{hash:R,randomBytes:k}=e;let{lowS:O,prehash:D,extraEntropy:M}=Y;O==null&&(O=!0),v=Be("msgHash",v),D&&(v=Be("prehashed msgHash",R(v)));const Z=K(v),J=l(U),ie=[he(J),he(Z)];if(M!=null&&M!==!1){const we=M===!0?k(t.BYTES):M;ie.push(Be("extraEntropy",we))}const Q=Kt(...ie),re=Z;function _e(we){const Re=L(we);if(!w(Re))return;const Pe=c(Re),qe=u.BASE.multiply(Re).toAffine(),Ee=a(qe.x);if(Ee===yt)return;const nt=a(Pe*a(re+Ee*J));if(nt===yt)return;let xt=(qe.x===Ee?0:2)|Number(qe.y&Qe),rn=nt;return O&&y(nt)&&(rn=d(nt),xt^=1),new m(Ee,rn,xt)}return{seed:Q,k2sig:_e}}const G={lowS:e.lowS,prehash:!1},Ae={lowS:e.lowS,prehash:!1};function Ie(v,U,Y=G){const{seed:R,k2sig:k}=ne(v,U,Y),O=e;return Ks(O.hash.outputLen,O.nByteLength,O.hmac)(R,k)}u.BASE._setWindowSize(8);function Xe(v,U,Y,R=Ae){var qe;const k=v;if(U=Be("msgHash",U),Y=Be("publicKey",Y),"strict"in R)throw new Error("options.strict was renamed to lowS");const{lowS:O,prehash:D}=R;let M,Z;try{if(typeof k=="string"||zt(k))try{M=m.fromDER(k)}catch(Ee){if(!(Ee instanceof Lt.Err))throw Ee;M=m.fromCompact(k)}else if(typeof k=="object"&&typeof k.r=="bigint"&&typeof k.s=="bigint"){const{r:Ee,s:nt}=k;M=new m(Ee,nt)}else throw new Error("PARSE");Z=u.fromHex(Y)}catch(Ee){if(Ee.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(O&&M.hasHighS())return!1;D&&(U=e.hash(U));const{r:J,s:ie}=M,Q=K(U),re=c(ie),_e=a(Q*re),we=a(J*re),Re=(qe=u.BASE.multiplyAndAddUnsafe(Z,_e,we))==null?void 0:qe.toAffine();return Re?a(Re.x)===J:!1}return{CURVE:e,getPublicKey:I,getSharedSecret:_,sign:Ie,verify:Xe,ProjectivePoint:u,Signature:m,utils:E}}class Ms extends di{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,hi(e);const n=fi(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,o=new Uint8Array(r);o.set(n.length>r?e.create().update(n).digest():n);for(let i=0;i<o.length;i++)o[i]^=54;this.iHash.update(o),this.oHash=e.create();for(let i=0;i<o.length;i++)o[i]^=106;this.oHash.update(o),o.fill(0)}update(e){return Xr(this),this.iHash.update(e),this}digestInto(e){Xr(this),gi(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:r,destroyed:o,blockLen:i,outputLen:a}=this;return e=e,e.finished=r,e.destroyed=o,e.blockLen=i,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Hs=(s,e,t)=>new Ms(s,e).update(t).digest();Hs.create=(s,e)=>new Ms(s,e);const[ji,Gi]=(()=>H.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(s=>BigInt(s))))(),kt=new Uint32Array(80),St=new Uint32Array(80);class Yi extends yi{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:n,Bl:r,Ch:o,Cl:i,Dh:a,Dl:c,Eh:u,El:l,Fh:h,Fl:w,Gh:p,Gl:y,Hh:d,Hl:f}=this;return[e,t,n,r,o,i,a,c,u,l,h,w,p,y,d,f]}set(e,t,n,r,o,i,a,c,u,l,h,w,p,y,d,f){this.Ah=e|0,this.Al=t|0,this.Bh=n|0,this.Bl=r|0,this.Ch=o|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=u|0,this.El=l|0,this.Fh=h|0,this.Fl=w|0,this.Gh=p|0,this.Gl=y|0,this.Hh=d|0,this.Hl=f|0}process(e,t){for(let I=0;I<16;I++,t+=4)kt[I]=e.getUint32(t),St[I]=e.getUint32(t+=4);for(let I=16;I<80;I++){const C=kt[I-15]|0,_=St[I-15]|0,L=H.rotrSH(C,_,1)^H.rotrSH(C,_,8)^H.shrSH(C,_,7),K=H.rotrSL(C,_,1)^H.rotrSL(C,_,8)^H.shrSL(C,_,7),F=kt[I-2]|0,he=St[I-2]|0,ne=H.rotrSH(F,he,19)^H.rotrBH(F,he,61)^H.shrSH(F,he,6),G=H.rotrSL(F,he,19)^H.rotrBL(F,he,61)^H.shrSL(F,he,6),Ae=H.add4L(K,G,St[I-7],St[I-16]),Ie=H.add4H(Ae,L,ne,kt[I-7],kt[I-16]);kt[I]=Ie|0,St[I]=Ae|0}let{Ah:n,Al:r,Bh:o,Bl:i,Ch:a,Cl:c,Dh:u,Dl:l,Eh:h,El:w,Fh:p,Fl:y,Gh:d,Gl:f,Hh:m,Hl:E}=this;for(let I=0;I<80;I++){const C=H.rotrSH(h,w,14)^H.rotrSH(h,w,18)^H.rotrBH(h,w,41),_=H.rotrSL(h,w,14)^H.rotrSL(h,w,18)^H.rotrBL(h,w,41),L=h&p^~h&d,K=w&y^~w&f,F=H.add5L(E,_,K,Gi[I],St[I]),he=H.add5H(F,m,C,L,ji[I],kt[I]),ne=F|0,G=H.rotrSH(n,r,28)^H.rotrBH(n,r,34)^H.rotrBH(n,r,39),Ae=H.rotrSL(n,r,28)^H.rotrBL(n,r,34)^H.rotrBL(n,r,39),Ie=n&o^n&a^o&a,Xe=r&i^r&c^i&c;m=d|0,E=f|0,d=p|0,f=y|0,p=h|0,y=w|0,{h,l:w}=H.add(u|0,l|0,he|0,ne|0),u=a|0,l=c|0,a=o|0,c=i|0,o=n|0,i=r|0;const v=H.add3L(ne,Ae,Xe);n=H.add3H(v,he,G,Ie),r=v|0}({h:n,l:r}=H.add(this.Ah|0,this.Al|0,n|0,r|0)),{h:o,l:i}=H.add(this.Bh|0,this.Bl|0,o|0,i|0),{h:a,l:c}=H.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:u,l}=H.add(this.Dh|0,this.Dl|0,u|0,l|0),{h,l:w}=H.add(this.Eh|0,this.El|0,h|0,w|0),{h:p,l:y}=H.add(this.Fh|0,this.Fl|0,p|0,y|0),{h:d,l:f}=H.add(this.Gh|0,this.Gl|0,d|0,f|0),{h:m,l:E}=H.add(this.Hh|0,this.Hl|0,m|0,E|0),this.set(n,r,o,i,a,c,u,l,h,w,p,y,d,f,m,E)}roundClean(){kt.fill(0),St.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const Zi=pi(()=>new Yi);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ji(s){return{hash:s,hmac:(e,...t)=>Hs(s,e,bi(...t)),randomBytes:Ls}}function Xi(s,e){const t=n=>Vi({...s,...Ji(n)});return Object.freeze({...t(e),create:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const rt=BigInt(0),Ge=BigInt(1),kn=BigInt(2),Qi=BigInt(8),ea={zip215:!0};function ta(s){const e=Ir(s);return Jt(s,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function na(s){const e=ta(s),{Fp:t,n,prehash:r,hash:o,randomBytes:i,nByteLength:a,h:c}=e,u=kn<<BigInt(a*8)-Ge,l=t.create,h=e.uvRatio||((R,k)=>{try{return{isValid:!0,value:t.sqrt(R*t.inv(k))}}catch{return{isValid:!1,value:rt}}}),w=e.adjustScalarBytes||(R=>R),p=e.domain||((R,k,O)=>{if(k.length||O)throw new Error("Contexts/pre-hash are not supported");return R}),y=R=>typeof R=="bigint"&&rt<R,d=(R,k)=>y(R)&&y(k)&&R<k,f=R=>R===rt||d(R,u);function m(R,k){if(d(R,k))return R;throw new Error(`Expected valid scalar < ${k}, got ${typeof R} ${R}`)}function E(R){return R===rt?R:m(R,n)}const I=new Map;function C(R){if(!(R instanceof _))throw new Error("ExtendedPoint expected")}class _{constructor(k,O,D,M){if(this.ex=k,this.ey=O,this.ez=D,this.et=M,!f(k))throw new Error("x required");if(!f(O))throw new Error("y required");if(!f(D))throw new Error("z required");if(!f(M))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(k){if(k instanceof _)throw new Error("extended point not allowed");const{x:O,y:D}=k||{};if(!f(O)||!f(D))throw new Error("invalid affine point");return new _(O,D,Ge,l(O*D))}static normalizeZ(k){const O=t.invertBatch(k.map(D=>D.ez));return k.map((D,M)=>D.toAffine(O[M])).map(_.fromAffine)}_setWindowSize(k){this._WINDOW_SIZE=k,I.delete(this)}assertValidity(){const{a:k,d:O}=e;if(this.is0())throw new Error("bad point: ZERO");const{ex:D,ey:M,ez:Z,et:J}=this,ie=l(D*D),Q=l(M*M),re=l(Z*Z),_e=l(re*re),we=l(ie*k),Re=l(re*l(we+Q)),Pe=l(_e+l(O*l(ie*Q)));if(Re!==Pe)throw new Error("bad point: equation left != right (1)");const qe=l(D*M),Ee=l(Z*J);if(qe!==Ee)throw new Error("bad point: equation left != right (2)")}equals(k){C(k);const{ex:O,ey:D,ez:M}=this,{ex:Z,ey:J,ez:ie}=k,Q=l(O*ie),re=l(Z*M),_e=l(D*ie),we=l(J*M);return Q===re&&_e===we}is0(){return this.equals(_.ZERO)}negate(){return new _(l(-this.ex),this.ey,this.ez,l(-this.et))}double(){const{a:k}=e,{ex:O,ey:D,ez:M}=this,Z=l(O*O),J=l(D*D),ie=l(kn*l(M*M)),Q=l(k*Z),re=O+D,_e=l(l(re*re)-Z-J),we=Q+J,Re=we-ie,Pe=Q-J,qe=l(_e*Re),Ee=l(we*Pe),nt=l(_e*Pe),xt=l(Re*we);return new _(qe,Ee,xt,nt)}add(k){C(k);const{a:O,d:D}=e,{ex:M,ey:Z,ez:J,et:ie}=this,{ex:Q,ey:re,ez:_e,et:we}=k;if(O===BigInt(-1)){const Hr=l((Z-M)*(re+Q)),Vr=l((Z+M)*(re-Q)),Gn=l(Vr-Hr);if(Gn===rt)return this.double();const jr=l(J*kn*we),Gr=l(ie*kn*_e),Yr=Gr+jr,Zr=Vr+Hr,Jr=Gr-jr,oi=l(Yr*Gn),ii=l(Zr*Jr),ai=l(Yr*Jr),ci=l(Gn*Zr);return new _(oi,ii,ci,ai)}const Re=l(M*Q),Pe=l(Z*re),qe=l(ie*D*we),Ee=l(J*_e),nt=l((M+Z)*(Q+re)-Re-Pe),xt=Ee-qe,rn=Ee+qe,Mr=l(Pe-O*Re),ti=l(nt*xt),ni=l(rn*Mr),ri=l(nt*Mr),si=l(xt*rn);return new _(ti,ni,si,ri)}subtract(k){return this.add(k.negate())}wNAF(k){return F.wNAFCached(this,I,k,_.normalizeZ)}multiply(k){const{p:O,f:D}=this.wNAF(m(k,n));return _.normalizeZ([O,D])[0]}multiplyUnsafe(k){let O=E(k);return O===rt?K:this.equals(K)||O===Ge?this:this.equals(L)?this.wNAF(O).p:F.unsafeLadder(this,O)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return F.unsafeLadder(this,n).is0()}toAffine(k){const{ex:O,ey:D,ez:M}=this,Z=this.is0();k==null&&(k=Z?Qi:t.inv(M));const J=l(O*k),ie=l(D*k),Q=l(M*k);if(Z)return{x:rt,y:Ge};if(Q!==Ge)throw new Error("invZ was invalid");return{x:J,y:ie}}clearCofactor(){const{h:k}=e;return k===Ge?this:this.multiplyUnsafe(k)}static fromHex(k,O=!1){const{d:D,a:M}=e,Z=t.BYTES;k=Be("pointHex",k,Z);const J=k.slice(),ie=k[Z-1];J[Z-1]=ie&-129;const Q=Mt(J);Q===rt||(O?m(Q,u):m(Q,t.ORDER));const re=l(Q*Q),_e=l(re-Ge),we=l(D*re-M);let{isValid:Re,value:Pe}=h(_e,we);if(!Re)throw new Error("Point.fromHex: invalid y coordinate");const qe=(Pe&Ge)===Ge,Ee=(ie&128)!==0;if(!O&&Pe===rt&&Ee)throw new Error("Point.fromHex: x=0 and x_0=1");return Ee!==qe&&(Pe=l(-Pe)),_.fromAffine({x:Pe,y:Q})}static fromPrivateKey(k){return G(k).point}toRawBytes(){const{x:k,y:O}=this.toAffine(),D=ln(O,t.BYTES);return D[D.length-1]|=k&Ge?128:0,D}toHex(){return Ut(this.toRawBytes())}}_.BASE=new _(e.Gx,e.Gy,Ge,l(e.Gx*e.Gy)),_.ZERO=new _(rt,Ge,Ge,rt);const{BASE:L,ZERO:K}=_,F=$s(_,a*8);function he(R){return pe(R,n)}function ne(R){return he(Mt(R))}function G(R){const k=a;R=Be("private key",R,k);const O=Be("hashed private key",o(R),2*k),D=w(O.slice(0,k)),M=O.slice(k,2*k),Z=ne(D),J=L.multiply(Z),ie=J.toRawBytes();return{head:D,prefix:M,scalar:Z,point:J,pointBytes:ie}}function Ae(R){return G(R).pointBytes}function Ie(R=new Uint8Array,...k){const O=Kt(...k);return ne(o(p(O,Be("context",R),!!r)))}function Xe(R,k,O={}){R=Be("message",R),r&&(R=r(R));const{prefix:D,scalar:M,pointBytes:Z}=G(k),J=Ie(O.context,D,R),ie=L.multiply(J).toRawBytes(),Q=Ie(O.context,ie,Z,R),re=he(J+Q*M);E(re);const _e=Kt(ie,ln(re,t.BYTES));return Be("result",_e,a*2)}const v=ea;function U(R,k,O,D=v){const{context:M,zip215:Z}=D,J=t.BYTES;R=Be("signature",R,2*J),k=Be("message",k),r&&(k=r(k));const ie=Mt(R.slice(J,2*J));let Q,re,_e;try{Q=_.fromHex(O,Z),re=_.fromHex(R.slice(0,J),Z),_e=L.multiplyUnsafe(ie)}catch{return!1}if(!Z&&Q.isSmallOrder())return!1;const we=Ie(M,re.toRawBytes(),Q.toRawBytes(),k);return re.add(Q.multiplyUnsafe(we)).subtract(_e).clearCofactor().equals(_.ZERO)}return L._setWindowSize(8),{CURVE:e,getPublicKey:Ae,sign:Xe,verify:U,ExtendedPoint:_,utils:{getExtendedPublicKey:G,randomPrivateKey:()=>i(t.BYTES),precompute(R=8,k=_.BASE){return k._setWindowSize(R),k.multiply(BigInt(3)),k}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Er=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),is=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const ra=BigInt(1),as=BigInt(2);BigInt(3);const sa=BigInt(5),oa=BigInt(8);function ia(s){const e=BigInt(10),t=BigInt(20),n=BigInt(40),r=BigInt(80),o=Er,a=s*s%o*s%o,c=ke(a,as,o)*a%o,u=ke(c,ra,o)*s%o,l=ke(u,sa,o)*u%o,h=ke(l,e,o)*l%o,w=ke(h,t,o)*h%o,p=ke(w,n,o)*w%o,y=ke(p,r,o)*p%o,d=ke(y,r,o)*p%o,f=ke(d,e,o)*l%o;return{pow_p_5_8:ke(f,as,o)*s%o,b2:a}}function aa(s){return s[0]&=248,s[31]&=127,s[31]|=64,s}function ca(s,e){const t=Er,n=pe(e*e*e,t),r=pe(n*n*e,t),o=ia(s*r).pow_p_5_8;let i=pe(s*n*o,t);const a=pe(e*i*i,t),c=i,u=pe(i*is,t),l=a===s,h=a===pe(-s,t),w=a===pe(-s*is,t);return l&&(i=c),(h||w)&&(i=u),Oi(i,t)&&(i=pe(-i,t)),{isValid:l||h,value:i}}const ua=(()=>Fs(Er,void 0,!0))(),la=(()=>({a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:ua,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:oa,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Zi,randomBytes:Ls,adjustScalarBytes:aa,uvRatio:ca}))(),Xt=(()=>na(la))();var Sn=wi.Buffer;function da(s){if(s.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),t=0;t<e.length;t++)e[t]=255;for(var n=0;n<s.length;n++){var r=s.charAt(n),o=r.charCodeAt(0);if(e[o]!==255)throw new TypeError(r+" is ambiguous");e[o]=n}var i=s.length,a=s.charAt(0),c=Math.log(i)/Math.log(256),u=Math.log(256)/Math.log(i);function l(p){if((Array.isArray(p)||p instanceof Uint8Array)&&(p=Sn.from(p)),!Sn.isBuffer(p))throw new TypeError("Expected Buffer");if(p.length===0)return"";for(var y=0,d=0,f=0,m=p.length;f!==m&&p[f]===0;)f++,y++;for(var E=(m-f)*u+1>>>0,I=new Uint8Array(E);f!==m;){for(var C=p[f],_=0,L=E-1;(C!==0||_<d)&&L!==-1;L--,_++)C+=256*I[L]>>>0,I[L]=C%i>>>0,C=C/i>>>0;if(C!==0)throw new Error("Non-zero carry");d=_,f++}for(var K=E-d;K!==E&&I[K]===0;)K++;for(var F=a.repeat(y);K<E;++K)F+=s.charAt(I[K]);return F}function h(p){if(typeof p!="string")throw new TypeError("Expected String");if(p.length===0)return Sn.alloc(0);for(var y=0,d=0,f=0;p[y]===a;)d++,y++;for(var m=(p.length-y)*c+1>>>0,E=new Uint8Array(m);y<p.length;){var I=e[p.charCodeAt(y)];if(I===255)return;for(var C=0,_=m-1;(I!==0||C<f)&&_!==-1;_--,C++)I+=i*E[_]>>>0,E[_]=I%256>>>0,I=I/256>>>0;if(I!==0)throw new Error("Non-zero carry");f=C,y++}for(var L=m-f;L!==m&&E[L]===0;)L++;var K=Sn.allocUnsafe(d+(m-L));K.fill(0,0,d);for(var F=d;L!==m;)K[F++]=E[L++];return K}function w(p){var y=h(p);if(y)return y;throw new Error("Non-base"+i+" character")}return{encode:l,decodeUnsafe:h,decode:w}}var ha=da,fa=ha,ga="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",Vs=fa(ga);const Ne=Cs(Vs);var Oe={};function bt(s,e,t){return e<=s&&s<=t}function Un(s){if(s===void 0)return{};if(s===Object(s))return s;throw TypeError("Could not convert argument to dictionary")}function pa(s){for(var e=String(s),t=e.length,n=0,r=[];n<t;){var o=e.charCodeAt(n);if(o<55296||o>57343)r.push(o);else if(56320<=o&&o<=57343)r.push(65533);else if(55296<=o&&o<=56319)if(n===t-1)r.push(65533);else{var i=s.charCodeAt(n+1);if(56320<=i&&i<=57343){var a=o&1023,c=i&1023;r.push(65536+(a<<10)+c),n+=1}else r.push(65533)}n+=1}return r}function ya(s){for(var e="",t=0;t<s.length;++t){var n=s[t];n<=65535?e+=String.fromCharCode(n):(n-=65536,e+=String.fromCharCode((n>>10)+55296,(n&1023)+56320))}return e}var _n=-1;function Ar(s){this.tokens=[].slice.call(s)}Ar.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():_n},prepend:function(s){if(Array.isArray(s))for(var e=s;e.length;)this.tokens.unshift(e.pop());else this.tokens.unshift(s)},push:function(s){if(Array.isArray(s))for(var e=s;e.length;)this.tokens.push(e.shift());else this.tokens.push(s)}};var jt=-1;function Jn(s,e){if(s)throw TypeError("Decoder error");return e||65533}var Bn="utf-8";function xn(s,e){if(!(this instanceof xn))return new xn(s,e);if(s=s!==void 0?String(s).toLowerCase():Bn,s!==Bn)throw new Error("Encoding not supported. Only utf-8 is supported");e=Un(e),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=!!e.fatal,this._ignoreBOM=!!e.ignoreBOM,Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}xn.prototype={decode:function(e,t){var n;typeof e=="object"&&e instanceof ArrayBuffer?n=new Uint8Array(e):typeof e=="object"&&"buffer"in e&&e.buffer instanceof ArrayBuffer?n=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):n=new Uint8Array(0),t=Un(t),this._streaming||(this._decoder=new ba({fatal:this._fatal}),this._BOMseen=!1),this._streaming=!!t.stream;for(var r=new Ar(n),o=[],i;!r.endOfStream()&&(i=this._decoder.handler(r,r.read()),i!==jt);)i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i));if(!this._streaming){do{if(i=this._decoder.handler(r,r.read()),i===jt)break;i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i))}while(!r.endOfStream());this._decoder=null}return o.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(o[0]===65279?(this._BOMseen=!0,o.shift()):this._BOMseen=!0),ya(o)}};function vn(s,e){if(!(this instanceof vn))return new vn(s,e);if(s=s!==void 0?String(s).toLowerCase():Bn,s!==Bn)throw new Error("Encoding not supported. Only utf-8 is supported");e=Un(e),this._streaming=!1,this._encoder=null,this._options={fatal:!!e.fatal},Object.defineProperty(this,"encoding",{value:"utf-8"})}vn.prototype={encode:function(e,t){e=e?String(e):"",t=Un(t),this._streaming||(this._encoder=new ma(this._options)),this._streaming=!!t.stream;for(var n=[],r=new Ar(pa(e)),o;!r.endOfStream()&&(o=this._encoder.handler(r,r.read()),o!==jt);)Array.isArray(o)?n.push.apply(n,o):n.push(o);if(!this._streaming){for(;o=this._encoder.handler(r,r.read()),o!==jt;)Array.isArray(o)?n.push.apply(n,o):n.push(o);this._encoder=null}return new Uint8Array(n)}};function ba(s){var e=s.fatal,t=0,n=0,r=0,o=128,i=191;this.handler=function(a,c){if(c===_n&&r!==0)return r=0,Jn(e);if(c===_n)return jt;if(r===0){if(bt(c,0,127))return c;if(bt(c,194,223))r=1,t=c-192;else if(bt(c,224,239))c===224&&(o=160),c===237&&(i=159),r=2,t=c-224;else if(bt(c,240,244))c===240&&(o=144),c===244&&(i=143),r=3,t=c-240;else return Jn(e);return t=t<<6*r,null}if(!bt(c,o,i))return t=r=n=0,o=128,i=191,a.prepend(c),Jn(e);if(o=128,i=191,n+=1,t+=c-128<<6*(r-n),n!==r)return null;var u=t;return t=r=n=0,u}}function ma(s){s.fatal,this.handler=function(e,t){if(t===_n)return jt;if(bt(t,0,127))return t;var n,r;bt(t,128,2047)?(n=1,r=192):bt(t,2048,65535)?(n=2,r=224):bt(t,65536,1114111)&&(n=3,r=240);for(var o=[(t>>6*n)+r];n>0;){var i=t>>6*(n-1);o.push(128|i&63),n-=1}return o}}const wa=Object.freeze(Object.defineProperty({__proto__:null,TextDecoder:xn,TextEncoder:vn},Symbol.toStringTag,{value:"Module"})),ka=Os(wa);var Sa=ct&&ct.__createBinding||(Object.create?function(s,e,t,n){n===void 0&&(n=t),Object.defineProperty(s,n,{enumerable:!0,get:function(){return e[t]}})}:function(s,e,t,n){n===void 0&&(n=t),s[n]=e[t]}),Ia=ct&&ct.__setModuleDefault||(Object.create?function(s,e){Object.defineProperty(s,"default",{enumerable:!0,value:e})}:function(s,e){s.default=e}),dt=ct&&ct.__decorate||function(s,e,t,n){var r=arguments.length,o=r<3?e:n===null?n=Object.getOwnPropertyDescriptor(e,t):n,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(s,e,t,n);else for(var a=s.length-1;a>=0;a--)(i=s[a])&&(o=(r<3?i(o):r>3?i(e,t,o):i(e,t))||o);return r>3&&o&&Object.defineProperty(e,t,o),o},Ea=ct&&ct.__importStar||function(s){if(s&&s.__esModule)return s;var e={};if(s!=null)for(var t in s)t!=="default"&&Object.hasOwnProperty.call(s,t)&&Sa(e,s,t);return Ia(e,s),e},js=ct&&ct.__importDefault||function(s){return s&&s.__esModule?s:{default:s}};Object.defineProperty(Oe,"__esModule",{value:!0});var Gs=Oe.deserializeUnchecked=eo=Oe.deserialize=Qs=Oe.serialize=Oe.BinaryReader=Oe.BinaryWriter=Oe.BorshError=Oe.baseDecode=Oe.baseEncode=void 0;const At=js(mi),Ys=js(Vs),Aa=Ea(ka),_a=typeof TextDecoder!="function"?Aa.TextDecoder:TextDecoder,Ba=new _a("utf-8",{fatal:!0});function xa(s){return typeof s=="string"&&(s=Buffer.from(s,"utf8")),Ys.default.encode(Buffer.from(s))}Oe.baseEncode=xa;function va(s){return Buffer.from(Ys.default.decode(s))}Oe.baseDecode=va;const Xn=1024;class $e extends Error{constructor(e){super(e),this.fieldPath=[],this.originalMessage=e}addToFieldPath(e){this.fieldPath.splice(0,0,e),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}Oe.BorshError=$e;class Zs{constructor(){this.buf=Buffer.alloc(Xn),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=Buffer.concat([this.buf,Buffer.alloc(Xn)]))}writeU8(e){this.maybeResize(),this.buf.writeUInt8(e,this.length),this.length+=1}writeU16(e){this.maybeResize(),this.buf.writeUInt16LE(e,this.length),this.length+=2}writeU32(e){this.maybeResize(),this.buf.writeUInt32LE(e,this.length),this.length+=4}writeU64(e){this.maybeResize(),this.writeBuffer(Buffer.from(new At.default(e).toArray("le",8)))}writeU128(e){this.maybeResize(),this.writeBuffer(Buffer.from(new At.default(e).toArray("le",16)))}writeU256(e){this.maybeResize(),this.writeBuffer(Buffer.from(new At.default(e).toArray("le",32)))}writeU512(e){this.maybeResize(),this.writeBuffer(Buffer.from(new At.default(e).toArray("le",64)))}writeBuffer(e){this.buf=Buffer.concat([Buffer.from(this.buf.subarray(0,this.length)),e,Buffer.alloc(Xn)]),this.length+=e.length}writeString(e){this.maybeResize();const t=Buffer.from(e,"utf8");this.writeU32(t.length),this.writeBuffer(t)}writeFixedArray(e){this.writeBuffer(Buffer.from(e))}writeArray(e,t){this.maybeResize(),this.writeU32(e.length);for(const n of e)this.maybeResize(),t(n)}toArray(){return this.buf.subarray(0,this.length)}}Oe.BinaryWriter=Zs;function ht(s,e,t){const n=t.value;t.value=function(...r){try{return n.apply(this,r)}catch(o){if(o instanceof RangeError){const i=o.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(i)>=0)throw new $e("Reached the end of buffer when deserializing")}throw o}}}class Je{constructor(e){this.buf=e,this.offset=0}readU8(){const e=this.buf.readUInt8(this.offset);return this.offset+=1,e}readU16(){const e=this.buf.readUInt16LE(this.offset);return this.offset+=2,e}readU32(){const e=this.buf.readUInt32LE(this.offset);return this.offset+=4,e}readU64(){const e=this.readBuffer(8);return new At.default(e,"le")}readU128(){const e=this.readBuffer(16);return new At.default(e,"le")}readU256(){const e=this.readBuffer(32);return new At.default(e,"le")}readU512(){const e=this.readBuffer(64);return new At.default(e,"le")}readBuffer(e){if(this.offset+e>this.buf.length)throw new $e(`Expected buffer length ${e} isn't within bounds`);const t=this.buf.slice(this.offset,this.offset+e);return this.offset+=e,t}readString(){const e=this.readU32(),t=this.readBuffer(e);try{return Ba.decode(t)}catch(n){throw new $e(`Error decoding UTF-8 string: ${n}`)}}readFixedArray(e){return new Uint8Array(this.readBuffer(e))}readArray(e){const t=this.readU32(),n=Array();for(let r=0;r<t;++r)n.push(e());return n}}dt([ht],Je.prototype,"readU8",null);dt([ht],Je.prototype,"readU16",null);dt([ht],Je.prototype,"readU32",null);dt([ht],Je.prototype,"readU64",null);dt([ht],Je.prototype,"readU128",null);dt([ht],Je.prototype,"readU256",null);dt([ht],Je.prototype,"readU512",null);dt([ht],Je.prototype,"readString",null);dt([ht],Je.prototype,"readFixedArray",null);dt([ht],Je.prototype,"readArray",null);Oe.BinaryReader=Je;function Js(s){return s.charAt(0).toUpperCase()+s.slice(1)}function Rt(s,e,t,n,r){try{if(typeof n=="string")r[`write${Js(n)}`](t);else if(n instanceof Array)if(typeof n[0]=="number"){if(t.length!==n[0])throw new $e(`Expecting byte array of length ${n[0]}, but got ${t.length} bytes`);r.writeFixedArray(t)}else if(n.length===2&&typeof n[1]=="number"){if(t.length!==n[1])throw new $e(`Expecting byte array of length ${n[1]}, but got ${t.length} bytes`);for(let o=0;o<n[1];o++)Rt(s,null,t[o],n[0],r)}else r.writeArray(t,o=>{Rt(s,e,o,n[0],r)});else if(n.kind!==void 0)switch(n.kind){case"option":{t==null?r.writeU8(0):(r.writeU8(1),Rt(s,e,t,n.type,r));break}case"map":{r.writeU32(t.size),t.forEach((o,i)=>{Rt(s,e,i,n.key,r),Rt(s,e,o,n.value,r)});break}default:throw new $e(`FieldType ${n} unrecognized`)}else Xs(s,t,r)}catch(o){throw o instanceof $e&&o.addToFieldPath(e),o}}function Xs(s,e,t){if(typeof e.borshSerialize=="function"){e.borshSerialize(t);return}const n=s.get(e.constructor);if(!n)throw new $e(`Class ${e.constructor.name} is missing in schema`);if(n.kind==="struct")n.fields.map(([r,o])=>{Rt(s,r,e[r],o,t)});else if(n.kind==="enum"){const r=e[n.field];for(let o=0;o<n.values.length;++o){const[i,a]=n.values[o];if(i===r){t.writeU8(o),Rt(s,i,e[i],a,t);break}}}else throw new $e(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Ra(s,e,t=Zs){const n=new t;return Xs(s,e,n),n.toArray()}var Qs=Oe.serialize=Ra;function Pt(s,e,t,n){try{if(typeof t=="string")return n[`read${Js(t)}`]();if(t instanceof Array){if(typeof t[0]=="number")return n.readFixedArray(t[0]);if(typeof t[1]=="number"){const r=[];for(let o=0;o<t[1];o++)r.push(Pt(s,null,t[0],n));return r}else return n.readArray(()=>Pt(s,e,t[0],n))}if(t.kind==="option")return n.readU8()?Pt(s,e,t.type,n):void 0;if(t.kind==="map"){let r=new Map;const o=n.readU32();for(let i=0;i<o;i++){const a=Pt(s,e,t.key,n),c=Pt(s,e,t.value,n);r.set(a,c)}return r}return _r(s,t,n)}catch(r){throw r instanceof $e&&r.addToFieldPath(e),r}}function _r(s,e,t){if(typeof e.borshDeserialize=="function")return e.borshDeserialize(t);const n=s.get(e);if(!n)throw new $e(`Class ${e.name} is missing in schema`);if(n.kind==="struct"){const r={};for(const[o,i]of s.get(e).fields)r[o]=Pt(s,o,i,t);return new e(r)}if(n.kind==="enum"){const r=t.readU8();if(r>=n.values.length)throw new $e(`Enum index: ${r} is out of range`);const[o,i]=n.values[r],a=Pt(s,o,i,t);return new e({[o]:a})}throw new $e(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Pa(s,e,t,n=Je){const r=new n(t),o=_r(s,e,r);if(r.offset<t.length)throw new $e(`Unexpected ${t.length-r.offset} bytes after deserialized data`);return o}var eo=Oe.deserialize=Pa;function Ta(s,e,t,n=Je){const r=new n(t);return _r(s,e,r)}Gs=Oe.deserializeUnchecked=Ta;var b={};Object.defineProperty(b,"__esModule",{value:!0});b.s16=b.s8=b.nu64be=b.u48be=b.u40be=b.u32be=b.u24be=b.u16be=Le=b.nu64=b.u48=b.u40=N=b.u32=b.u24=et=b.u16=te=b.u8=Bt=b.offset=b.greedy=b.Constant=b.UTF8=b.CString=b.Blob=b.Boolean=b.BitField=b.BitStructure=b.VariantLayout=b.Union=b.UnionLayoutDiscriminator=b.UnionDiscriminator=b.Structure=b.Sequence=b.DoubleBE=b.Double=b.FloatBE=b.Float=b.NearInt64BE=b.NearInt64=b.NearUInt64BE=b.NearUInt64=b.IntBE=b.Int=b.UIntBE=b.UInt=b.OffsetLayout=b.GreedyCount=b.ExternalLayout=b.bindConstructorLayout=b.nameWithProperty=b.Layout=b.uint8ArrayToBuffer=b.checkUint8Array=void 0;b.constant=b.utf8=b.cstr=ge=b.blob=b.unionLayoutDiscriminator=b.union=Ue=b.seq=b.bits=z=b.struct=b.f64be=b.f64=b.f32be=b.f32=b.ns64be=b.s48be=b.s40be=b.s32be=b.s24be=b.s16be=Ye=b.ns64=b.s48=b.s40=b.s32=b.s24=void 0;const Br=q;function Qt(s){if(!(s instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}b.checkUint8Array=Qt;function oe(s){return Qt(s),Br.Buffer.from(s.buffer,s.byteOffset,s.length)}b.uint8ArrayToBuffer=oe;class ue{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}}b.Layout=ue;function xr(s,e){return e.property?s+"["+e.property+"]":s}b.nameWithProperty=xr;function La(s,e){if(typeof s!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(s,"layout_"))throw new Error("Class is already bound to a layout");if(!(e&&e instanceof ue))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(e,"boundConstructor_"))throw new Error("layout is already bound to a constructor");s.layout_=e,e.boundConstructor_=s,e.makeDestinationObject=()=>new s,Object.defineProperty(s.prototype,"encode",{value(t,n){return e.encode(this,t,n)},writable:!0}),Object.defineProperty(s,"decode",{value(t,n){return e.decode(t,n)},writable:!0})}b.bindConstructorLayout=La;class je extends ue{isCount(){throw new Error("ExternalLayout is abstract")}}b.ExternalLayout=je;class to extends je{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){Qt(e);const n=e.length-t;return Math.floor(n/this.elementSpan)}encode(e,t,n){return 0}}b.GreedyCount=to;class vr extends je{constructor(e,t=0,n){if(!(e instanceof ue))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,n||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof tt||this.layout instanceof st}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,n=0){return this.layout.encode(e,t,n+this.offset)}}b.OffsetLayout=vr;class tt extends ue{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return oe(e).readUIntLE(t,this.span)}encode(e,t,n=0){return oe(t).writeUIntLE(e,n,this.span),this.span}}b.UInt=tt;class st extends ue{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return oe(e).readUIntBE(t,this.span)}encode(e,t,n=0){return oe(t).writeUIntBE(e,n,this.span),this.span}}b.UIntBE=st;class Wt extends ue{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return oe(e).readIntLE(t,this.span)}encode(e,t,n=0){return oe(t).writeIntLE(e,n,this.span),this.span}}b.Int=Wt;class en extends ue{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return oe(e).readIntBE(t,this.span)}encode(e,t,n=0){return oe(t).writeIntBE(e,n,this.span),this.span}}b.IntBE=en;const gr=Math.pow(2,32);function Kn(s){const e=Math.floor(s/gr),t=s-e*gr;return{hi32:e,lo32:t}}function Wn(s,e){return s*gr+e}class no extends ue{constructor(e){super(8,e)}decode(e,t=0){const n=oe(e),r=n.readUInt32LE(t),o=n.readUInt32LE(t+4);return Wn(o,r)}encode(e,t,n=0){const r=Kn(e),o=oe(t);return o.writeUInt32LE(r.lo32,n),o.writeUInt32LE(r.hi32,n+4),8}}b.NearUInt64=no;class ro extends ue{constructor(e){super(8,e)}decode(e,t=0){const n=oe(e),r=n.readUInt32BE(t),o=n.readUInt32BE(t+4);return Wn(r,o)}encode(e,t,n=0){const r=Kn(e),o=oe(t);return o.writeUInt32BE(r.hi32,n),o.writeUInt32BE(r.lo32,n+4),8}}b.NearUInt64BE=ro;class so extends ue{constructor(e){super(8,e)}decode(e,t=0){const n=oe(e),r=n.readUInt32LE(t),o=n.readInt32LE(t+4);return Wn(o,r)}encode(e,t,n=0){const r=Kn(e),o=oe(t);return o.writeUInt32LE(r.lo32,n),o.writeInt32LE(r.hi32,n+4),8}}b.NearInt64=so;class oo extends ue{constructor(e){super(8,e)}decode(e,t=0){const n=oe(e),r=n.readInt32BE(t),o=n.readUInt32BE(t+4);return Wn(r,o)}encode(e,t,n=0){const r=Kn(e),o=oe(t);return o.writeInt32BE(r.hi32,n),o.writeUInt32BE(r.lo32,n+4),8}}b.NearInt64BE=oo;class io extends ue{constructor(e){super(4,e)}decode(e,t=0){return oe(e).readFloatLE(t)}encode(e,t,n=0){return oe(t).writeFloatLE(e,n),4}}b.Float=io;class ao extends ue{constructor(e){super(4,e)}decode(e,t=0){return oe(e).readFloatBE(t)}encode(e,t,n=0){return oe(t).writeFloatBE(e,n),4}}b.FloatBE=ao;class co extends ue{constructor(e){super(8,e)}decode(e,t=0){return oe(e).readDoubleLE(t)}encode(e,t,n=0){return oe(t).writeDoubleLE(e,n),8}}b.Double=co;class uo extends ue{constructor(e){super(8,e)}decode(e,t=0){return oe(e).readDoubleBE(t)}encode(e,t,n=0){return oe(t).writeDoubleBE(e,n),8}}b.DoubleBE=uo;class lo extends ue{constructor(e,t,n){if(!(e instanceof ue))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof je&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let r=-1;!(t instanceof je)&&0<e.span&&(r=t*e.span),super(r,n),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0,r=this.count;if(r instanceof je&&(r=r.decode(e,t)),0<this.elementLayout.span)n=r*this.elementLayout.span;else{let o=0;for(;o<r;)n+=this.elementLayout.getSpan(e,t+n),++o}return n}decode(e,t=0){const n=[];let r=0,o=this.count;for(o instanceof je&&(o=o.decode(e,t));r<o;)n.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),r+=1;return n}encode(e,t,n=0){const r=this.elementLayout,o=e.reduce((i,a)=>i+r.encode(a,t,n+i),0);return this.count instanceof je&&this.count.encode(e.length,t,n),o}}b.Sequence=lo;class ho extends ue{constructor(e,t,n){if(!(Array.isArray(e)&&e.reduce((o,i)=>o&&i instanceof ue,!0)))throw new TypeError("fields must be array of Layout instances");typeof t=="boolean"&&n===void 0&&(n=t,t=void 0);for(const o of e)if(0>o.span&&o.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let r=-1;try{r=e.reduce((o,i)=>o+i.getSpan(),0)}catch{}super(r,t),this.fields=e,this.decodePrefixes=!!n}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;try{n=this.fields.reduce((r,o)=>{const i=o.getSpan(e,t);return t+=i,r+i},0)}catch{throw new RangeError("indeterminate span")}return n}decode(e,t=0){Qt(e);const n=this.makeDestinationObject();for(const r of this.fields)if(r.property!==void 0&&(n[r.property]=r.decode(e,t)),t+=r.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return n}encode(e,t,n=0){const r=n;let o=0,i=0;for(const a of this.fields){let c=a.span;if(i=0<c?c:0,a.property!==void 0){const u=e[a.property];u!==void 0&&(i=a.encode(u,t,n),0>c&&(c=a.getSpan(t,n)))}o=n,n+=c}return o+i-r}fromArray(e){const t=this.makeDestinationObject();for(const n of this.fields)n.property!==void 0&&0<e.length&&(t[n.property]=e.shift());return t}layoutFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}offsetOf(e){if(typeof e!="string")throw new TypeError("property must be string");let t=0;for(const n of this.fields){if(n.property===e)return t;0>n.span?t=-1:0<=t&&(t+=n.span)}}}b.Structure=ho;class Rr{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,n){throw new Error("UnionDiscriminator is abstract")}}b.UnionDiscriminator=Rr;class Rn extends Rr{constructor(e,t){if(!(e instanceof je&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,n){return this.layout.encode(e,t,n)}}b.UnionLayoutDiscriminator=Rn;class Pr extends ue{constructor(e,t,n){let r;if(e instanceof tt||e instanceof st)r=new Rn(new vr(e));else if(e instanceof je&&e.isCount())r=new Rn(e);else if(e instanceof Rr)r=e;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(t===void 0&&(t=null),!(t===null||t instanceof ue))throw new TypeError("defaultLayout must be null or a Layout");if(t!==null){if(0>t.span)throw new Error("defaultLayout must have constant span");t.property===void 0&&(t=t.replicate("content"))}let o=-1;t&&(o=t.span,0<=o&&(e instanceof tt||e instanceof st)&&(o+=r.layout.span)),super(o,n),this.discriminator=r,this.usesPrefixDiscriminator=e instanceof tt||e instanceof st,this.defaultLayout=t,this.registry={};let i=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(a){return i(a)},this.configGetSourceVariant=function(a){i=a.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;const n=this.getVariant(e,t);if(!n)throw new Error("unable to determine span for unrecognized variant");return n.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;const t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(const t in this.registry){const n=this.registry[t];if(n.property&&Object.prototype.hasOwnProperty.call(e,n.property))return n}throw new Error("unable to infer src variant")}decode(e,t=0){let n;const r=this.discriminator,o=r.decode(e,t),i=this.registry[o];if(i===void 0){const a=this.defaultLayout;let c=0;this.usesPrefixDiscriminator&&(c=r.layout.span),n=this.makeDestinationObject(),n[r.property]=o,n[a.property]=a.decode(e,t+c)}else n=i.decode(e,t);return n}encode(e,t,n=0){const r=this.getSourceVariant(e);if(r===void 0){const o=this.discriminator,i=this.defaultLayout;let a=0;return this.usesPrefixDiscriminator&&(a=o.layout.span),o.encode(e[o.property],t,n),a+i.encode(e[i.property],t,n+a)}return r.encode(e,t,n)}addVariant(e,t,n){const r=new fo(this,e,t,n);return this.registry[e]=r,r}getVariant(e,t=0){let n;return e instanceof Uint8Array?n=this.discriminator.decode(e,t):n=e,this.registry[n]}}b.Union=Pr;class fo extends ue{constructor(e,t,n,r){if(!(e instanceof Pr))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if(typeof n=="string"&&r===void 0&&(r=n,n=null),n){if(!(n instanceof ue))throw new TypeError("layout must be a Layout");if(e.defaultLayout!==null&&0<=n.span&&n.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof r!="string")throw new TypeError("variant must have a String property")}let o=e.span;0>e.span&&(o=n?n.span:0,0<=o&&e.usesPrefixDiscriminator&&(o+=e.discriminator.layout.span)),super(o,r),this.union=e,this.variant=t,this.layout=n||null}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span);let r=0;return this.layout&&(r=this.layout.getSpan(e,t+n)),n+r}decode(e,t=0){const n=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let r=0;return this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span),this.layout?n[this.property]=this.layout.decode(e,t+r):this.property?n[this.property]=!0:this.union.usesPrefixDiscriminator&&(n[this.union.discriminator.property]=this.variant),n}encode(e,t,n=0){let r=0;if(this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,n);let o=r;if(this.layout&&(this.layout.encode(e[this.property],t,n+r),o+=this.layout.getSpan(t,n+r),0<=this.union.span&&o>this.union.span))throw new Error("encoded variant overruns containing union");return o}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}b.VariantLayout=fo;function $t(s){return 0>s&&(s+=4294967296),s}class Tr extends ue{constructor(e,t,n){if(!(e instanceof tt||e instanceof st))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof t=="string"&&n===void 0&&(n=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,n),this.word=e,this.msb=!!t,this.fields=[];let r=0;this._packedSetValue=function(o){return r=$t(o),this},this._packedGetValue=function(){return r}}decode(e,t=0){const n=this.makeDestinationObject(),r=this.word.decode(e,t);this._packedSetValue(r);for(const o of this.fields)o.property!==void 0&&(n[o.property]=o.decode(e));return n}encode(e,t,n=0){const r=this.word.decode(t,n);this._packedSetValue(r);for(const o of this.fields)if(o.property!==void 0){const i=e[o.property];i!==void 0&&o.encode(i)}return this.word.encode(this._packedGetValue(),t,n)}addField(e,t){const n=new Lr(this,e,t);return this.fields.push(n),n}addBoolean(e){const t=new go(this,e);return this.fields.push(t),t}fieldFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}}b.BitStructure=Tr;class Lr{constructor(e,t,n){if(!(e instanceof Tr))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");const r=8*e.span,o=e.fields.reduce((i,a)=>i+a.bits,0);if(t+o>r)throw new Error("bits too long for span remainder ("+(r-o)+" of "+r+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,t===32&&(this.valueMask=4294967295),this.start=o,this.container.msb&&(this.start=r-o-t),this.wordMask=$t(this.valueMask<<this.start),this.property=n}decode(e,t){const n=this.container._packedGetValue();return $t(n&this.wordMask)>>>this.start}encode(e){if(typeof e!="number"||!Number.isInteger(e)||e!==$t(e&this.valueMask))throw new TypeError(xr("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const t=this.container._packedGetValue(),n=$t(e<<this.start);this.container._packedSetValue($t(t&~this.wordMask)|n)}}b.BitField=Lr;let go=class extends Lr{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){typeof e=="boolean"&&(e=+e),super.encode(e)}};b.Boolean=go;class po extends ue{constructor(e,t){if(!(e instanceof je&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let n=-1;e instanceof je||(n=e),super(n,t),this.length=e}getSpan(e,t){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),n}decode(e,t=0){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),oe(e).slice(t,t+n)}encode(e,t,n){let r=this.length;if(this.length instanceof je&&(r=e.length),!(e instanceof Uint8Array&&r===e.length))throw new TypeError(xr("Blob.encode",this)+" requires (length "+r+") Uint8Array as src");if(n+r>t.length)throw new RangeError("encoding overruns Uint8Array");const o=oe(e);return oe(t).write(o.toString("hex"),n,r,"hex"),this.length instanceof je&&this.length.encode(r,t,n),r}}b.Blob=po;class yo extends ue{constructor(e){super(-1,e)}getSpan(e,t=0){Qt(e);let n=t;for(;n<e.length&&e[n]!==0;)n+=1;return 1+n-t}decode(e,t=0){const n=this.getSpan(e,t);return oe(e).slice(t,t+n-1).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));const r=Br.Buffer.from(e,"utf8"),o=r.length;if(n+o>t.length)throw new RangeError("encoding overruns Buffer");const i=oe(t);return r.copy(i,n),i[n+o]=0,o+1}}b.CString=yo;class bo extends ue{constructor(e,t){if(typeof e=="string"&&t===void 0&&(t=e,e=void 0),e===void 0)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return Qt(e),e.length-t}decode(e,t=0){const n=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<n)throw new RangeError("text length exceeds maxSpan");return oe(e).slice(t,t+n).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));const r=Br.Buffer.from(e,"utf8"),o=r.length;if(0<=this.maxSpan&&this.maxSpan<o)throw new RangeError("text length exceeds maxSpan");if(n+o>t.length)throw new RangeError("encoding overruns Buffer");return r.copy(oe(t),n),o}}b.UTF8=bo;class mo extends ue{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,n){return 0}}b.Constant=mo;b.greedy=(s,e)=>new to(s,e);var Bt=b.offset=(s,e,t)=>new vr(s,e,t),te=b.u8=s=>new tt(1,s),et=b.u16=s=>new tt(2,s);b.u24=s=>new tt(3,s);var N=b.u32=s=>new tt(4,s);b.u40=s=>new tt(5,s);b.u48=s=>new tt(6,s);var Le=b.nu64=s=>new no(s);b.u16be=s=>new st(2,s);b.u24be=s=>new st(3,s);b.u32be=s=>new st(4,s);b.u40be=s=>new st(5,s);b.u48be=s=>new st(6,s);b.nu64be=s=>new ro(s);b.s8=s=>new Wt(1,s);b.s16=s=>new Wt(2,s);b.s24=s=>new Wt(3,s);b.s32=s=>new Wt(4,s);b.s40=s=>new Wt(5,s);b.s48=s=>new Wt(6,s);var Ye=b.ns64=s=>new so(s);b.s16be=s=>new en(2,s);b.s24be=s=>new en(3,s);b.s32be=s=>new en(4,s);b.s40be=s=>new en(5,s);b.s48be=s=>new en(6,s);b.ns64be=s=>new oo(s);b.f32=s=>new io(s);b.f32be=s=>new ao(s);b.f64=s=>new co(s);b.f64be=s=>new uo(s);var z=b.struct=(s,e,t)=>new ho(s,e,t);b.bits=(s,e,t)=>new Tr(s,e,t);var Ue=b.seq=(s,e,t)=>new lo(s,e,t);b.union=(s,e,t)=>new Pr(s,e,t);b.unionLayoutDiscriminator=(s,e)=>new Rn(s,e);var ge=b.blob=(s,e)=>new po(s,e);b.cstr=s=>new yo(s);b.utf8=(s,e)=>new bo(s,e);b.constant=(s,e)=>new mo(s,e);var pn={};Object.defineProperty(pn,"__esModule",{value:!0});function Ca(s){{const e=Buffer.from(s);e.reverse();const t=e.toString("hex");return t.length===0?BigInt(0):BigInt(`0x${t}`)}}var Oa=pn.toBigIntLE=Ca;function Na(s){{const e=s.toString("hex");return e.length===0?BigInt(0):BigInt(`0x${e}`)}}pn.toBigIntBE=Na;function za(s,e){{const t=s.toString(16),n=Buffer.from(t.padStart(e*2,"0").slice(0,e*2),"hex");return n.reverse(),n}}var wo=pn.toBufferLE=za;function Ua(s,e){{const t=s.toString(16);return Buffer.from(t.padStart(e*2,"0").slice(0,e*2),"hex")}}pn.toBufferBE=Ua;class Ka extends TypeError{constructor(e,t){let n;const{message:r,explanation:o,...i}=e,{path:a}=e,c=a.length===0?r:`At path: ${a.join(".")} -- ${r}`;super(o??c),o!=null&&(this.cause=c),Object.assign(this,i),this.name=this.constructor.name,this.failures=()=>n??(n=[e,...t()])}}function Wa(s){return yn(s)&&typeof s[Symbol.iterator]=="function"}function yn(s){return typeof s=="object"&&s!=null}function Pn(s){return yn(s)&&!Array.isArray(s)}function ot(s){return typeof s=="symbol"?s.toString():typeof s=="string"?JSON.stringify(s):`${s}`}function Fa(s){const{done:e,value:t}=s.next();return e?void 0:t}function Da(s,e,t,n){if(s===!0)return;s===!1?s={}:typeof s=="string"&&(s={message:s});const{path:r,branch:o}=e,{type:i}=t,{refinement:a,message:c=`Expected a value of type \`${i}\`${a?` with refinement \`${a}\``:""}, but received: \`${ot(n)}\``}=s;return{value:n,type:i,refinement:a,key:r[r.length-1],path:r,branch:o,...s,message:c}}function*cs(s,e,t,n){Wa(s)||(s=[s]);for(const r of s){const o=Da(r,e,t,n);o&&(yield o)}}function*Cr(s,e,t={}){const{path:n=[],branch:r=[s],coerce:o=!1,mask:i=!1}=t,a={path:n,branch:r,mask:i};o&&(s=e.coercer(s,a));let c="valid";for(const u of e.validator(s,a))u.explanation=t.message,c="not_valid",yield[u,void 0];for(let[u,l,h]of e.entries(s,a)){const w=Cr(l,h,{path:u===void 0?n:[...n,u],branch:u===void 0?r:[...r,l],coerce:o,mask:i,message:t.message});for(const p of w)p[0]?(c=p[0].refinement!=null?"not_refined":"not_valid",yield[p[0],void 0]):o&&(l=p[1],u===void 0?s=l:s instanceof Map?s.set(u,l):s instanceof Set?s.add(l):yn(s)&&(l!==void 0||u in s)&&(s[u]=l))}if(c!=="not_valid")for(const u of e.refiner(s,a))u.explanation=t.message,c="not_refined",yield[u,void 0];c==="valid"&&(yield[void 0,s])}let ft=class{constructor(e){const{type:t,schema:n,validator:r,refiner:o,coercer:i=c=>c,entries:a=function*(){}}=e;this.type=t,this.schema=n,this.entries=a,this.coercer=i,r?this.validator=(c,u)=>{const l=r(c,u);return cs(l,u,this,c)}:this.validator=()=>[],o?this.refiner=(c,u)=>{const l=o(c,u);return cs(l,u,this,c)}:this.refiner=()=>[]}assert(e,t){return ko(e,this,t)}create(e,t){return B(e,this,t)}is(e){return So(e,this)}mask(e,t){return qa(e,this,t)}validate(e,t={}){return bn(e,this,t)}};function ko(s,e,t){const n=bn(s,e,{message:t});if(n[0])throw n[0]}function B(s,e,t){const n=bn(s,e,{coerce:!0,message:t});if(n[0])throw n[0];return n[1]}function qa(s,e,t){const n=bn(s,e,{coerce:!0,mask:!0,message:t});if(n[0])throw n[0];return n[1]}function So(s,e){return!bn(s,e)[0]}function bn(s,e,t={}){const n=Cr(s,e,t),r=Fa(n);return r[0]?[new Ka(r[0],function*(){for(const i of n)i[0]&&(yield i[0])}),void 0]:[void 0,r[1]]}function Ft(s,e){return new ft({type:s,schema:null,validator:e})}function $a(){return Ft("any",()=>!0)}function P(s){return new ft({type:"array",schema:s,*entries(e){if(s&&Array.isArray(e))for(const[t,n]of e.entries())yield[t,n,s]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||`Expected an array value, but received: ${ot(e)}`}})}function ut(){return Ft("boolean",s=>typeof s=="boolean")}function Or(s){return Ft("instance",e=>e instanceof s||`Expected a \`${s.name}\` instance, but received: ${ot(e)}`)}function ye(s){const e=ot(s),t=typeof s;return new ft({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?s:null,validator(n){return n===s||`Expected the literal \`${e}\`, but received: ${ot(n)}`}})}function Ma(){return Ft("never",()=>!1)}function T(s){return new ft({...s,validator:(e,t)=>e===null||s.validator(e,t),refiner:(e,t)=>e===null||s.refiner(e,t)})}function g(){return Ft("number",s=>typeof s=="number"&&!isNaN(s)||`Expected a number, but received: ${ot(s)}`)}function $(s){return new ft({...s,validator:(e,t)=>e===void 0||s.validator(e,t),refiner:(e,t)=>e===void 0||s.refiner(e,t)})}function Io(s,e){return new ft({type:"record",schema:null,*entries(t){if(yn(t))for(const n in t){const r=t[n];yield[n,n,s],yield[n,r,e]}},validator(t){return Pn(t)||`Expected an object, but received: ${ot(t)}`},coercer(t){return Pn(t)?{...t}:t}})}function A(){return Ft("string",s=>typeof s=="string"||`Expected a string, but received: ${ot(s)}`)}function Nr(s){const e=Ma();return new ft({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){const n=Math.max(s.length,t.length);for(let r=0;r<n;r++)yield[r,t[r],s[r]||e]}},validator(t){return Array.isArray(t)||`Expected an array, but received: ${ot(t)}`},coercer(t){return Array.isArray(t)?t.slice():t}})}function S(s){const e=Object.keys(s);return new ft({type:"type",schema:s,*entries(t){if(yn(t))for(const n of e)yield[n,t[n],s[n]]},validator(t){return Pn(t)||`Expected an object, but received: ${ot(t)}`},coercer(t){return Pn(t)?{...t}:t}})}function Me(s){const e=s.map(t=>t.type).join(" | ");return new ft({type:"union",schema:null,coercer(t,n){for(const r of s){const[o,i]=r.validate(t,{coerce:!0,mask:n.mask});if(!o)return i}return t},validator(t,n){const r=[];for(const o of s){const[...i]=Cr(t,o,n),[a]=i;if(a[0])for(const[c]of i)c&&r.push(c);else return[]}return[`Expected the value to satisfy a union of \`${e}\`, but received: ${ot(t)}`,...r]}})}function tn(){return Ft("unknown",()=>!0)}function mn(s,e,t){return new ft({...s,coercer:(n,r)=>So(n,e)?s.coercer(t(n,r),r):s.coercer(n,r)})}var In,Ha=new Uint8Array(16);function Eo(){if(!In&&(In=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!In))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return In(Ha)}const Va=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function Fn(s){return typeof s=="string"&&Va.test(s)}var Te=[];for(var Qn=0;Qn<256;++Qn)Te.push((Qn+256).toString(16).substr(1));function Dn(s){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,t=(Te[s[e+0]]+Te[s[e+1]]+Te[s[e+2]]+Te[s[e+3]]+"-"+Te[s[e+4]]+Te[s[e+5]]+"-"+Te[s[e+6]]+Te[s[e+7]]+"-"+Te[s[e+8]]+Te[s[e+9]]+"-"+Te[s[e+10]]+Te[s[e+11]]+Te[s[e+12]]+Te[s[e+13]]+Te[s[e+14]]+Te[s[e+15]]).toLowerCase();if(!Fn(t))throw TypeError("Stringified UUID is invalid");return t}var us,er,tr=0,nr=0;function ja(s,e,t){var n=e&&t||0,r=e||new Array(16);s=s||{};var o=s.node||us,i=s.clockseq!==void 0?s.clockseq:er;if(o==null||i==null){var a=s.random||(s.rng||Eo)();o==null&&(o=us=[a[0]|1,a[1],a[2],a[3],a[4],a[5]]),i==null&&(i=er=(a[6]<<8|a[7])&16383)}var c=s.msecs!==void 0?s.msecs:Date.now(),u=s.nsecs!==void 0?s.nsecs:nr+1,l=c-tr+(u-nr)/1e4;if(l<0&&s.clockseq===void 0&&(i=i+1&16383),(l<0||c>tr)&&s.nsecs===void 0&&(u=0),u>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");tr=c,nr=u,er=i,c+=122192928e5;var h=((c&268435455)*1e4+u)%4294967296;r[n++]=h>>>24&255,r[n++]=h>>>16&255,r[n++]=h>>>8&255,r[n++]=h&255;var w=c/4294967296*1e4&268435455;r[n++]=w>>>8&255,r[n++]=w&255,r[n++]=w>>>24&15|16,r[n++]=w>>>16&255,r[n++]=i>>>8|128,r[n++]=i&255;for(var p=0;p<6;++p)r[n+p]=o[p];return e||Dn(r)}function Ao(s){if(!Fn(s))throw TypeError("Invalid UUID");var e,t=new Uint8Array(16);return t[0]=(e=parseInt(s.slice(0,8),16))>>>24,t[1]=e>>>16&255,t[2]=e>>>8&255,t[3]=e&255,t[4]=(e=parseInt(s.slice(9,13),16))>>>8,t[5]=e&255,t[6]=(e=parseInt(s.slice(14,18),16))>>>8,t[7]=e&255,t[8]=(e=parseInt(s.slice(19,23),16))>>>8,t[9]=e&255,t[10]=(e=parseInt(s.slice(24,36),16))/1099511627776&255,t[11]=e/4294967296&255,t[12]=e>>>24&255,t[13]=e>>>16&255,t[14]=e>>>8&255,t[15]=e&255,t}function Ga(s){s=unescape(encodeURIComponent(s));for(var e=[],t=0;t<s.length;++t)e.push(s.charCodeAt(t));return e}var Ya="6ba7b810-9dad-11d1-80b4-00c04fd430c8",Za="6ba7b811-9dad-11d1-80b4-00c04fd430c8";function _o(s,e,t){function n(r,o,i,a){if(typeof r=="string"&&(r=Ga(r)),typeof o=="string"&&(o=Ao(o)),o.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var c=new Uint8Array(16+r.length);if(c.set(o),c.set(r,o.length),c=t(c),c[6]=c[6]&15|e,c[8]=c[8]&63|128,i){a=a||0;for(var u=0;u<16;++u)i[a+u]=c[u];return i}return Dn(c)}try{n.name=s}catch{}return n.DNS=Ya,n.URL=Za,n}function Ja(s){if(typeof s=="string"){var e=unescape(encodeURIComponent(s));s=new Uint8Array(e.length);for(var t=0;t<e.length;++t)s[t]=e.charCodeAt(t)}return Xa(Qa(ec(s),s.length*8))}function Xa(s){for(var e=[],t=s.length*32,n="0123456789abcdef",r=0;r<t;r+=8){var o=s[r>>5]>>>r%32&255,i=parseInt(n.charAt(o>>>4&15)+n.charAt(o&15),16);e.push(i)}return e}function Bo(s){return(s+64>>>9<<4)+14+1}function Qa(s,e){s[e>>5]|=128<<e%32,s[Bo(e)-1]=e;for(var t=1732584193,n=-271733879,r=-1732584194,o=271733878,i=0;i<s.length;i+=16){var a=t,c=n,u=r,l=o;t=Ke(t,n,r,o,s[i],7,-680876936),o=Ke(o,t,n,r,s[i+1],12,-389564586),r=Ke(r,o,t,n,s[i+2],17,606105819),n=Ke(n,r,o,t,s[i+3],22,-1044525330),t=Ke(t,n,r,o,s[i+4],7,-176418897),o=Ke(o,t,n,r,s[i+5],12,1200080426),r=Ke(r,o,t,n,s[i+6],17,-1473231341),n=Ke(n,r,o,t,s[i+7],22,-45705983),t=Ke(t,n,r,o,s[i+8],7,1770035416),o=Ke(o,t,n,r,s[i+9],12,-1958414417),r=Ke(r,o,t,n,s[i+10],17,-42063),n=Ke(n,r,o,t,s[i+11],22,-1990404162),t=Ke(t,n,r,o,s[i+12],7,1804603682),o=Ke(o,t,n,r,s[i+13],12,-40341101),r=Ke(r,o,t,n,s[i+14],17,-1502002290),n=Ke(n,r,o,t,s[i+15],22,1236535329),t=We(t,n,r,o,s[i+1],5,-165796510),o=We(o,t,n,r,s[i+6],9,-1069501632),r=We(r,o,t,n,s[i+11],14,643717713),n=We(n,r,o,t,s[i],20,-373897302),t=We(t,n,r,o,s[i+5],5,-701558691),o=We(o,t,n,r,s[i+10],9,38016083),r=We(r,o,t,n,s[i+15],14,-660478335),n=We(n,r,o,t,s[i+4],20,-405537848),t=We(t,n,r,o,s[i+9],5,568446438),o=We(o,t,n,r,s[i+14],9,-1019803690),r=We(r,o,t,n,s[i+3],14,-187363961),n=We(n,r,o,t,s[i+8],20,1163531501),t=We(t,n,r,o,s[i+13],5,-1444681467),o=We(o,t,n,r,s[i+2],9,-51403784),r=We(r,o,t,n,s[i+7],14,1735328473),n=We(n,r,o,t,s[i+12],20,-1926607734),t=Fe(t,n,r,o,s[i+5],4,-378558),o=Fe(o,t,n,r,s[i+8],11,-2022574463),r=Fe(r,o,t,n,s[i+11],16,1839030562),n=Fe(n,r,o,t,s[i+14],23,-35309556),t=Fe(t,n,r,o,s[i+1],4,-1530992060),o=Fe(o,t,n,r,s[i+4],11,1272893353),r=Fe(r,o,t,n,s[i+7],16,-155497632),n=Fe(n,r,o,t,s[i+10],23,-1094730640),t=Fe(t,n,r,o,s[i+13],4,681279174),o=Fe(o,t,n,r,s[i],11,-358537222),r=Fe(r,o,t,n,s[i+3],16,-722521979),n=Fe(n,r,o,t,s[i+6],23,76029189),t=Fe(t,n,r,o,s[i+9],4,-640364487),o=Fe(o,t,n,r,s[i+12],11,-421815835),r=Fe(r,o,t,n,s[i+15],16,530742520),n=Fe(n,r,o,t,s[i+2],23,-995338651),t=De(t,n,r,o,s[i],6,-198630844),o=De(o,t,n,r,s[i+7],10,1126891415),r=De(r,o,t,n,s[i+14],15,-1416354905),n=De(n,r,o,t,s[i+5],21,-57434055),t=De(t,n,r,o,s[i+12],6,1700485571),o=De(o,t,n,r,s[i+3],10,-1894986606),r=De(r,o,t,n,s[i+10],15,-1051523),n=De(n,r,o,t,s[i+1],21,-2054922799),t=De(t,n,r,o,s[i+8],6,1873313359),o=De(o,t,n,r,s[i+15],10,-30611744),r=De(r,o,t,n,s[i+6],15,-1560198380),n=De(n,r,o,t,s[i+13],21,1309151649),t=De(t,n,r,o,s[i+4],6,-145523070),o=De(o,t,n,r,s[i+11],10,-1120210379),r=De(r,o,t,n,s[i+2],15,718787259),n=De(n,r,o,t,s[i+9],21,-343485551),t=_t(t,a),n=_t(n,c),r=_t(r,u),o=_t(o,l)}return[t,n,r,o]}function ec(s){if(s.length===0)return[];for(var e=s.length*8,t=new Uint32Array(Bo(e)),n=0;n<e;n+=8)t[n>>5]|=(s[n/8]&255)<<n%32;return t}function _t(s,e){var t=(s&65535)+(e&65535),n=(s>>16)+(e>>16)+(t>>16);return n<<16|t&65535}function tc(s,e){return s<<e|s>>>32-e}function qn(s,e,t,n,r,o){return _t(tc(_t(_t(e,s),_t(n,o)),r),t)}function Ke(s,e,t,n,r,o,i){return qn(e&t|~e&n,s,e,r,o,i)}function We(s,e,t,n,r,o,i){return qn(e&n|t&~n,s,e,r,o,i)}function Fe(s,e,t,n,r,o,i){return qn(e^t^n,s,e,r,o,i)}function De(s,e,t,n,r,o,i){return qn(t^(e|~n),s,e,r,o,i)}var nc=_o("v3",48,Ja);const rc=nc;function sc(s,e,t){s=s||{};var n=s.random||(s.rng||Eo)();if(n[6]=n[6]&15|64,n[8]=n[8]&63|128,e){t=t||0;for(var r=0;r<16;++r)e[t+r]=n[r];return e}return Dn(n)}function oc(s,e,t,n){switch(s){case 0:return e&t^~e&n;case 1:return e^t^n;case 2:return e&t^e&n^t&n;case 3:return e^t^n}}function rr(s,e){return s<<e|s>>>32-e}function ic(s){var e=[1518500249,1859775393,2400959708,3395469782],t=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof s=="string"){var n=unescape(encodeURIComponent(s));s=[];for(var r=0;r<n.length;++r)s.push(n.charCodeAt(r))}else Array.isArray(s)||(s=Array.prototype.slice.call(s));s.push(128);for(var o=s.length/4+2,i=Math.ceil(o/16),a=new Array(i),c=0;c<i;++c){for(var u=new Uint32Array(16),l=0;l<16;++l)u[l]=s[c*64+l*4]<<24|s[c*64+l*4+1]<<16|s[c*64+l*4+2]<<8|s[c*64+l*4+3];a[c]=u}a[i-1][14]=(s.length-1)*8/Math.pow(2,32),a[i-1][14]=Math.floor(a[i-1][14]),a[i-1][15]=(s.length-1)*8&4294967295;for(var h=0;h<i;++h){for(var w=new Uint32Array(80),p=0;p<16;++p)w[p]=a[h][p];for(var y=16;y<80;++y)w[y]=rr(w[y-3]^w[y-8]^w[y-14]^w[y-16],1);for(var d=t[0],f=t[1],m=t[2],E=t[3],I=t[4],C=0;C<80;++C){var _=Math.floor(C/20),L=rr(d,5)+oc(_,f,m,E)+I+e[_]+w[C]>>>0;I=E,E=m,m=rr(f,30)>>>0,f=d,d=L}t[0]=t[0]+d>>>0,t[1]=t[1]+f>>>0,t[2]=t[2]+m>>>0,t[3]=t[3]+E>>>0,t[4]=t[4]+I>>>0}return[t[0]>>24&255,t[0]>>16&255,t[0]>>8&255,t[0]&255,t[1]>>24&255,t[1]>>16&255,t[1]>>8&255,t[1]&255,t[2]>>24&255,t[2]>>16&255,t[2]>>8&255,t[2]&255,t[3]>>24&255,t[3]>>16&255,t[3]>>8&255,t[3]&255,t[4]>>24&255,t[4]>>16&255,t[4]>>8&255,t[4]&255]}var ac=_o("v5",80,ic);const cc=ac,uc="00000000-0000-0000-0000-000000000000";function lc(s){if(!Fn(s))throw TypeError("Invalid UUID");return parseInt(s.substr(14,1),16)}const dc=Object.freeze(Object.defineProperty({__proto__:null,NIL:uc,parse:Ao,stringify:Dn,v1:ja,v3:rc,v4:sc,v5:cc,validate:Fn,version:lc},Symbol.toStringTag,{value:"Module"})),xo=Os(dc),hc=xo.v4,fc=function(s,e,t,n){if(typeof s!="string")throw new TypeError(s+" must be a string");n=n||{};const r=typeof n.version=="number"?n.version:2;if(r!==1&&r!==2)throw new TypeError(r+" must be 1 or 2");const o={method:s};if(r===2&&(o.jsonrpc="2.0"),e){if(typeof e!="object"&&!Array.isArray(e))throw new TypeError(e+" must be an object, array or omitted");o.params=e}if(typeof t>"u"){const i=typeof n.generator=="function"?n.generator:function(){return hc()};o.id=i(o,n)}else r===2&&t===null?n.notificationIdNull&&(o.id=null):o.id=t;return o};var gc=fc;const pc=xo.v4,yc=gc,dn=function(s,e){if(!(this instanceof dn))return new dn(s,e);e||(e={}),this.options={reviver:typeof e.reviver<"u"?e.reviver:null,replacer:typeof e.replacer<"u"?e.replacer:null,generator:typeof e.generator<"u"?e.generator:function(){return pc()},version:typeof e.version<"u"?e.version:2,notificationIdNull:typeof e.notificationIdNull=="boolean"?e.notificationIdNull:!1},this.callServer=s};var bc=dn;dn.prototype.request=function(s,e,t,n){const r=this;let o=null;const i=Array.isArray(s)&&typeof e=="function";if(this.options.version===1&&i)throw new TypeError("JSON-RPC 1.0 does not support batching");if(i||!i&&s&&typeof s=="object"&&typeof e=="function")n=e,o=s;else{typeof t=="function"&&(n=t,t=void 0);const u=typeof n=="function";try{o=yc(s,e,t,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(l){if(u)return n(l);throw l}if(!u)return o}let c;try{c=JSON.stringify(o,this.options.replacer)}catch(u){return n(u)}return this.callServer(c,function(u,l){r._parseResponse(u,l,n)}),o};dn.prototype._parseResponse=function(s,e,t){if(s){t(s);return}if(!e)return t();let n;try{n=JSON.parse(e,this.options.reviver)}catch(r){return t(r)}if(t.length===3)if(Array.isArray(n)){const r=function(i){return typeof i.error<"u"},o=function(i){return!r(i)};return t(null,n.filter(r),n.filter(o))}else return t(null,n.error,n.result);t(null,n)};const mc=Cs(bc);var wc=class extends Ns{constructor(e,t,n){super();xe(this,"socket");this.socket=new window.WebSocket(e,n),this.socket.onopen=()=>this.emit("open"),this.socket.onmessage=r=>this.emit("message",r.data),this.socket.onerror=r=>this.emit("error",r),this.socket.onclose=r=>{this.emit("close",r.code,r.reason)}}send(e,t,n){const r=n||t;try{this.socket.send(e),r()}catch(o){r(o)}}close(e,t){this.socket.close(e,t)}addEventListener(e,t,n){this.socket.addEventListener(e,t,n)}};function kc(s,e){return new wc(s,e)}var Sc=class{encode(s){return JSON.stringify(s)}decode(s){return JSON.parse(s)}},Ic=class extends Ns{constructor(e,t="ws://localhost:8080",{autoconnect:n=!0,reconnect:r=!0,reconnect_interval:o=1e3,max_reconnects:i=5,...a}={},c,u){super();xe(this,"address");xe(this,"rpc_id");xe(this,"queue");xe(this,"options");xe(this,"autoconnect");xe(this,"ready");xe(this,"reconnect");xe(this,"reconnect_timer_id");xe(this,"reconnect_interval");xe(this,"max_reconnects");xe(this,"rest_options");xe(this,"current_reconnects");xe(this,"generate_request_id");xe(this,"socket");xe(this,"webSocketFactory");xe(this,"dataPack");this.webSocketFactory=e,this.queue={},this.rpc_id=0,this.address=t,this.autoconnect=n,this.ready=!1,this.reconnect=r,this.reconnect_timer_id=void 0,this.reconnect_interval=o,this.max_reconnects=i,this.rest_options=a,this.current_reconnects=0,this.generate_request_id=c||(()=>++this.rpc_id),u?this.dataPack=u:this.dataPack=new Sc,this.autoconnect&&this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}connect(){this.socket||this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}call(e,t,n,r){return!r&&typeof n=="object"&&(r=n,n=null),new Promise((o,i)=>{if(!this.ready)return i(new Error("socket not ready"));const a=this.generate_request_id(e,t),c={jsonrpc:"2.0",method:e,params:t||void 0,id:a};this.socket.send(this.dataPack.encode(c),r,u=>{if(u)return i(u);this.queue[a]={promise:[o,i]},n&&(this.queue[a].timeout=setTimeout(()=>{delete this.queue[a],i(new Error("reply timeout"))},n))})})}async login(e){const t=await this.call("rpc.login",e);if(!t)throw new Error("authentication failed");return t}async listMethods(){return await this.call("__listMethods")}notify(e,t){return new Promise((n,r)=>{if(!this.ready)return r(new Error("socket not ready"));const o={jsonrpc:"2.0",method:e,params:t};this.socket.send(this.dataPack.encode(o),i=>{if(i)return r(i);n()})})}async subscribe(e){typeof e=="string"&&(e=[e]);const t=await this.call("rpc.on",e);if(typeof e=="string"&&t[e]!=="ok")throw new Error("Failed subscribing to an event '"+e+"' with: "+t[e]);return t}async unsubscribe(e){typeof e=="string"&&(e=[e]);const t=await this.call("rpc.off",e);if(typeof e=="string"&&t[e]!=="ok")throw new Error("Failed unsubscribing from an event with: "+t);return t}close(e,t){this.socket.close(e||1e3,t)}setAutoReconnect(e){this.reconnect=e}setReconnectInterval(e){this.reconnect_interval=e}setMaxReconnects(e){this.max_reconnects=e}_connect(e,t){clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(e,t),this.socket.addEventListener("open",()=>{this.ready=!0,this.emit("open"),this.current_reconnects=0}),this.socket.addEventListener("message",({data:n})=>{n instanceof ArrayBuffer&&(n=q.Buffer.from(n).toString());try{n=this.dataPack.decode(n)}catch{return}if(n.notification&&this.listeners(n.notification).length){if(!Object.keys(n.params).length)return this.emit(n.notification);const r=[n.notification];if(n.params.constructor===Object)r.push(n.params);else for(let o=0;o<n.params.length;o++)r.push(n.params[o]);return Promise.resolve().then(()=>{this.emit.apply(this,r)})}if(!this.queue[n.id])return n.method?Promise.resolve().then(()=>{this.emit(n.method,n==null?void 0:n.params)}):void 0;"error"in n=="result"in n&&this.queue[n.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),this.queue[n.id].timeout&&clearTimeout(this.queue[n.id].timeout),n.error?this.queue[n.id].promise[1](n.error):this.queue[n.id].promise[0](n.result),delete this.queue[n.id]}),this.socket.addEventListener("error",n=>this.emit("error",n)),this.socket.addEventListener("close",({code:n,reason:r})=>{this.ready&&setTimeout(()=>this.emit("close",n,r),0),this.ready=!1,this.socket=void 0,n!==1e3&&(this.current_reconnects++,this.reconnect&&(this.max_reconnects>this.current_reconnects||this.max_reconnects===0)&&(this.reconnect_timer_id=setTimeout(()=>this._connect(e,t),this.reconnect_interval)))})}};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const vo=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),ls=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Ec=BigInt(1),pr=BigInt(2),ds=(s,e)=>(s+e/pr)/e;function Ac(s){const e=vo,t=BigInt(3),n=BigInt(6),r=BigInt(11),o=BigInt(22),i=BigInt(23),a=BigInt(44),c=BigInt(88),u=s*s*s%e,l=u*u*s%e,h=ke(l,t,e)*l%e,w=ke(h,t,e)*l%e,p=ke(w,pr,e)*u%e,y=ke(p,r,e)*p%e,d=ke(y,o,e)*y%e,f=ke(d,a,e)*d%e,m=ke(f,c,e)*f%e,E=ke(m,a,e)*d%e,I=ke(E,t,e)*l%e,C=ke(I,i,e)*y%e,_=ke(C,n,e)*u%e,L=ke(_,pr,e);if(!yr.eql(yr.sqr(L),s))throw new Error("Cannot find square root");return L}const yr=Fs(vo,void 0,void 0,{sqrt:Ac}),$n=Xi({a:BigInt(0),b:BigInt(7),Fp:yr,n:ls,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:s=>{const e=ls,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Ec*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),r=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=t,i=BigInt("0x100000000000000000000000000000000"),a=ds(o*s,e),c=ds(-n*s,e);let u=pe(s-a*t-c*r,e),l=pe(-a*n-c*o,e);const h=u>i,w=l>i;if(h&&(u=e-u),w&&(l=e-l),u>i||l>i)throw new Error("splitScalar: Endomorphism failed, k="+s);return{k1neg:h,k1:u,k2neg:w,k2:l}}}},dr);BigInt(0);$n.ProjectivePoint;const _c=Xt.utils.randomPrivateKey,hs=()=>{const s=Xt.utils.randomPrivateKey(),e=Tn(s),t=new Uint8Array(64);return t.set(s),t.set(e,32),{publicKey:e,secretKey:t}},Tn=Xt.getPublicKey;function fs(s){try{return Xt.ExtendedPoint.fromHex(s),!0}catch{return!1}}const zr=(s,e)=>Xt.sign(s,e.slice(0,32)),Bc=Xt.verify,j=s=>q.Buffer.isBuffer(s)?s:s instanceof Uint8Array?q.Buffer.from(s.buffer,s.byteOffset,s.byteLength):q.Buffer.from(s);class Ro{constructor(e){Object.assign(this,e)}encode(){return q.Buffer.from(Qs(An,this))}static decode(e){return eo(An,this,e)}static decodeUnchecked(e){return Gs(An,this,e)}}class zl extends Ro{constructor(e){if(super(e),this.enum="",Object.keys(e).length!==1)throw new Error("Enum can only take single value");Object.keys(e).map(t=>{this.enum=t})}}const An=new Map;var Po;const xc=32,wt=32;function vc(s){return s._bn!==void 0}let gs=1;class x extends Ro{constructor(e){if(super({}),this._bn=void 0,vc(e))this._bn=e._bn;else{if(typeof e=="string"){const t=Ne.decode(e);if(t.length!=wt)throw new Error("Invalid public key input");this._bn=new es(t)}else this._bn=new es(e);if(this._bn.byteLength()>wt)throw new Error("Invalid public key input")}}static unique(){const e=new x(gs);return gs+=1,new x(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return Ne.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(q.Buffer);if(e.length===wt)return e;const t=q.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,n){const r=q.Buffer.concat([e.toBuffer(),q.Buffer.from(t),n.toBuffer()]),o=dr(r);return new x(o)}static createProgramAddressSync(e,t){let n=q.Buffer.alloc(0);e.forEach(function(o){if(o.length>xc)throw new TypeError("Max seed length exceeded");n=q.Buffer.concat([n,j(o)])}),n=q.Buffer.concat([n,t.toBuffer(),q.Buffer.from("ProgramDerivedAddress")]);const r=dr(n);if(fs(r))throw new Error("Invalid seeds, address must fall off the curve");return new x(r)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let n=255,r;for(;n!=0;){try{const o=e.concat(q.Buffer.from([n]));r=this.createProgramAddressSync(o,t)}catch(o){if(o instanceof TypeError)throw o;n--;continue}return[r,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new x(e);return fs(t.toBytes())}}Po=x;x.default=new Po("11111111111111111111111111111111");An.set(x,{kind:"struct",fields:[["_bn","u256"]]});class Ul{constructor(e){if(this._publicKey=void 0,this._secretKey=void 0,e){const t=j(e);if(e.length!==64)throw new Error("bad secret key size");this._publicKey=t.slice(32,64),this._secretKey=t.slice(0,32)}else this._secretKey=j(_c()),this._publicKey=j(Tn(this._secretKey))}get publicKey(){return new x(this._publicKey)}get secretKey(){return q.Buffer.concat([this._secretKey,this._publicKey],64)}}const Kl=new x("BPFLoader1111111111111111111111111111111111"),Nt=1280-40-8,Ur=127,Ln=64;class To extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(To.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class Lo extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Lo.prototype,"name",{value:"TransactionExpiredTimeoutError"});class on extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(on.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class Cn{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>255+1)throw new Error("Account index overflow encountered during compilation");const n=new Map;this.keySegments().flat().forEach((o,i)=>{n.set(o.toBase58(),i)});const r=o=>{const i=n.get(o.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return e.map(o=>({programIdIndex:r(o.programId),accountKeyIndexes:o.keys.map(i=>r(i.pubkey)),data:o.data}))}}const X=(s="publicKey")=>ge(32,s),Rc=(s="signature")=>ge(64,s),Ct=(s="string")=>{const e=z([N("length"),N("lengthPadding"),ge(Bt(N(),-8),"chars")],s),t=e.decode.bind(e),n=e.encode.bind(e),r=e;return r.decode=(o,i)=>t(o,i).chars.toString(),r.encode=(o,i,a)=>{const c={chars:q.Buffer.from(o,"utf8")};return n(c,i,a)},r.alloc=o=>N().span+N().span+q.Buffer.from(o,"utf8").length,r},Pc=(s="authorized")=>z([X("staker"),X("withdrawer")],s),Tc=(s="lockup")=>z([Ye("unixTimestamp"),Ye("epoch"),X("custodian")],s),Lc=(s="voteInit")=>z([X("nodePubkey"),X("authorizedVoter"),X("authorizedWithdrawer"),te("commission")],s),Cc=(s="voteAuthorizeWithSeedArgs")=>z([N("voteAuthorizationType"),X("currentAuthorityDerivedKeyOwnerPubkey"),Ct("currentAuthorityDerivedKeySeed"),X("newAuthorized")],s);function Co(s,e){const t=r=>{if(r.span>=0)return r.span;if(typeof r.alloc=="function")return r.alloc(e[r.property]);if("count"in r&&"elementLayout"in r){const o=e[r.property];if(Array.isArray(o))return o.length*t(r.elementLayout)}else if("fields"in r)return Co({layout:r},e[r.property]);return 0};let n=0;return s.layout.fields.forEach(r=>{n+=t(r)}),n}function He(s){let e=0,t=0;for(;;){let n=s.shift();if(e|=(n&127)<<t*7,t+=1,!(n&128))break}return e}function Ze(s,e){let t=e;for(;;){let n=t&127;if(t>>=7,t==0){s.push(n);break}else n|=128,s.push(n)}}function se(s,e){if(!s)throw new Error(e||"Assertion failed")}class Mn{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const n=new Map,r=i=>{const a=i.toBase58();let c=n.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(a,c)),c},o=r(t);o.isSigner=!0,o.isWritable=!0;for(const i of e){r(i.programId).isInvoked=!0;for(const a of i.keys){const c=r(a.pubkey);c.isSigner||(c.isSigner=a.isSigner),c.isWritable||(c.isWritable=a.isWritable)}}return new Mn(t,n)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];se(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,c])=>c.isSigner&&c.isWritable),n=e.filter(([,c])=>c.isSigner&&!c.isWritable),r=e.filter(([,c])=>!c.isSigner&&c.isWritable),o=e.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:t.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:o.length};{se(t.length>0,"Expected at least one writable signer key");const[c]=t[0];se(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const a=[...t.map(([c])=>new x(c)),...n.map(([c])=>new x(c)),...r.map(([c])=>new x(c)),...o.map(([c])=>new x(c))];return[i,a]}extractTableLookup(e){const[t,n]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[r,o]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(t.length===0&&r.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:r},{writable:n,readonly:o}]}drainKeysFoundInLookupTable(e,t){const n=new Array,r=new Array;for(const[o,i]of this.keyMetaMap.entries())if(t(i)){const a=new x(o),c=e.findIndex(u=>u.equals(a));c>=0&&(se(c<256,"Max lookup table index exceeded"),n.push(c),r.push(a),this.keyMetaMap.delete(o))}return[n,r]}}const Oo="Reached end of buffer unexpectedly";function it(s){if(s.length===0)throw new Error(Oo);return s.shift()}function Ve(s,...e){const[t]=e;if(e.length===2?t+(e[1]??0)>s.length:t>=s.length)throw new Error(Oo);return s.splice(...e)}class lt{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new x(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:Ne.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new Cn(this.staticAccountKeys)}static compile(e){const t=Mn.compile(e.instructions,e.payerKey),[n,r]=t.getMessageComponents(),i=new Cn(r).compileInstructions(e.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:Ne.encode(a.data)}));return new lt({header:n,accountKeys:r,recentBlockhash:e.recentBlockhash,instructions:i})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const n=e-t,o=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return n<o}else{const n=t-this.header.numReadonlySignedAccounts;return e<n}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];Ze(t,e);const n=this.instructions.map(h=>{const{accounts:w,programIdIndex:p}=h,y=Array.from(Ne.decode(h.data));let d=[];Ze(d,w.length);let f=[];return Ze(f,y.length),{programIdIndex:p,keyIndicesCount:q.Buffer.from(d),keyIndices:w,dataLength:q.Buffer.from(f),data:y}});let r=[];Ze(r,n.length);let o=q.Buffer.alloc(Nt);q.Buffer.from(r).copy(o);let i=r.length;n.forEach(h=>{const p=z([te("programIdIndex"),ge(h.keyIndicesCount.length,"keyIndicesCount"),Ue(te("keyIndex"),h.keyIndices.length,"keyIndices"),ge(h.dataLength.length,"dataLength"),Ue(te("userdatum"),h.data.length,"data")]).encode(h,o,i);i+=p}),o=o.slice(0,i);const a=z([ge(1,"numRequiredSignatures"),ge(1,"numReadonlySignedAccounts"),ge(1,"numReadonlyUnsignedAccounts"),ge(t.length,"keyCount"),Ue(X("key"),e,"keys"),X("recentBlockhash")]),c={numRequiredSignatures:q.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:q.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:q.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:q.Buffer.from(t),keys:this.accountKeys.map(h=>j(h.toBytes())),recentBlockhash:Ne.decode(this.recentBlockhash)};let u=q.Buffer.alloc(2048);const l=a.encode(c,u);return o.copy(u,l),u.slice(0,l+o.length)}static from(e){let t=[...e];const n=it(t);if(n!==(n&Ur))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const r=it(t),o=it(t),i=He(t);let a=[];for(let w=0;w<i;w++){const p=Ve(t,0,wt);a.push(new x(q.Buffer.from(p)))}const c=Ve(t,0,wt),u=He(t);let l=[];for(let w=0;w<u;w++){const p=it(t),y=He(t),d=Ve(t,0,y),f=He(t),m=Ve(t,0,f),E=Ne.encode(q.Buffer.from(m));l.push({programIdIndex:p,accounts:d,data:E})}const h={header:{numRequiredSignatures:n,numReadonlySignedAccounts:r,numReadonlyUnsignedAccounts:o},recentBlockhash:Ne.encode(q.Buffer.from(c)),accountKeys:a,instructions:l};return new lt(h)}}class Gt{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new Cn(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(e>=n){const r=e-n,o=this.addressTableLookups.reduce((i,a)=>i+a.writableIndexes.length,0);return r<o}else if(e>=this.header.numRequiredSignatures){const r=e-t,i=n-t-this.header.numReadonlyUnsignedAccounts;return r<i}else{const r=t-this.header.numReadonlySignedAccounts;return e<r}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const n of this.addressTableLookups){const r=e.find(o=>o.key.equals(n.accountKey));if(!r)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(const o of n.writableIndexes)if(o<r.state.addresses.length)t.writable.push(r.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`);for(const o of n.readonlyIndexes)if(o<r.state.addresses.length)t.readonly.push(r.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`)}return t}static compile(e){const t=Mn.compile(e.instructions,e.payerKey),n=new Array,r={writable:new Array,readonly:new Array},o=e.addressLookupTableAccounts||[];for(const l of o){const h=t.extractTableLookup(l);if(h!==void 0){const[w,{writable:p,readonly:y}]=h;n.push(w),r.writable.push(...p),r.readonly.push(...y)}}const[i,a]=t.getMessageComponents(),u=new Cn(a,r).compileInstructions(e.instructions);return new Gt({header:i,staticAccountKeys:a,recentBlockhash:e.recentBlockhash,compiledInstructions:u,addressTableLookups:n})}serialize(){const e=Array();Ze(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),n=Array();Ze(n,this.compiledInstructions.length);const r=this.serializeAddressTableLookups(),o=Array();Ze(o,this.addressTableLookups.length);const i=z([te("prefix"),z([te("numRequiredSignatures"),te("numReadonlySignedAccounts"),te("numReadonlyUnsignedAccounts")],"header"),ge(e.length,"staticAccountKeysLength"),Ue(X(),this.staticAccountKeys.length,"staticAccountKeys"),X("recentBlockhash"),ge(n.length,"instructionsLength"),ge(t.length,"serializedInstructions"),ge(o.length,"addressTableLookupsLength"),ge(r.length,"serializedAddressTableLookups")]),a=new Uint8Array(Nt),c=128,u=i.encode({prefix:c,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(l=>l.toBytes()),recentBlockhash:Ne.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:r},a);return a.slice(0,u)}serializeInstructions(){let e=0;const t=new Uint8Array(Nt);for(const n of this.compiledInstructions){const r=Array();Ze(r,n.accountKeyIndexes.length);const o=Array();Ze(o,n.data.length);const i=z([te("programIdIndex"),ge(r.length,"encodedAccountKeyIndexesLength"),Ue(te(),n.accountKeyIndexes.length,"accountKeyIndexes"),ge(o.length,"encodedDataLength"),ge(n.data.length,"data")]);e+=i.encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(r),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:n.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(Nt);for(const n of this.addressTableLookups){const r=Array();Ze(r,n.writableIndexes.length);const o=Array();Ze(o,n.readonlyIndexes.length);const i=z([X("accountKey"),ge(r.length,"encodedWritableIndexesLength"),Ue(te(),n.writableIndexes.length,"writableIndexes"),ge(o.length,"encodedReadonlyIndexesLength"),Ue(te(),n.readonlyIndexes.length,"readonlyIndexes")]);e+=i.encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(r),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:n.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const n=it(t),r=n&Ur;se(n!==r,"Expected versioned message but received legacy message");const o=r;se(o===0,`Expected versioned message with version 0 but found version ${o}`);const i={numRequiredSignatures:it(t),numReadonlySignedAccounts:it(t),numReadonlyUnsignedAccounts:it(t)},a=[],c=He(t);for(let y=0;y<c;y++)a.push(new x(Ve(t,0,wt)));const u=Ne.encode(Ve(t,0,wt)),l=He(t),h=[];for(let y=0;y<l;y++){const d=it(t),f=He(t),m=Ve(t,0,f),E=He(t),I=new Uint8Array(Ve(t,0,E));h.push({programIdIndex:d,accountKeyIndexes:m,data:I})}const w=He(t),p=[];for(let y=0;y<w;y++){const d=new x(Ve(t,0,wt)),f=He(t),m=Ve(t,0,f),E=He(t),I=Ve(t,0,E);p.push({accountKey:d,writableIndexes:m,readonlyIndexes:I})}return new Gt({header:i,staticAccountKeys:a,recentBlockhash:u,compiledInstructions:h,addressTableLookups:p})}}const No={deserializeMessageVersion(s){const e=s[0],t=e&Ur;return t===e?"legacy":t},deserialize:s=>{const e=No.deserializeMessageVersion(s);if(e==="legacy")return lt.from(s);if(e===0)return Gt.deserialize(s);throw new Error(`Transaction message version ${e} deserialization is not supported`)}};let It=function(s){return s[s.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",s[s.PROCESSED=1]="PROCESSED",s[s.TIMED_OUT=2]="TIMED_OUT",s[s.NONCE_INVALID=3]="NONCE_INVALID",s}({});const Oc=q.Buffer.alloc(Ln).fill(0);class de{constructor(e){this.keys=void 0,this.programId=void 0,this.data=q.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:n})=>({pubkey:e.toJSON(),isSigner:t,isWritable:n})),programId:this.programId.toJSON(),data:[...this.data]}}}class ce{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:n}=e;this.minNonceContextSlot=t,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:n}=e;this.recentBlockhash=t,this.lastValidBlockHeight=n}else{const{recentBlockhash:t,nonceInfo:n}=e;n&&(this.nonceInfo=n),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new de(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let n;if(this.feePayer)n=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)n=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let d=0;d<t.length;d++)if(t[d].programId===void 0)throw new Error(`Transaction instruction index ${d} has undefined program id`);const r=[],o=[];t.forEach(d=>{d.keys.forEach(m=>{o.push({...m})});const f=d.programId.toString();r.includes(f)||r.push(f)}),r.forEach(d=>{o.push({pubkey:new x(d),isSigner:!1,isWritable:!1})});const i=[];o.forEach(d=>{const f=d.pubkey.toString(),m=i.findIndex(E=>E.pubkey.toString()===f);m>-1?(i[m].isWritable=i[m].isWritable||d.isWritable,i[m].isSigner=i[m].isSigner||d.isSigner):i.push(d)}),i.sort(function(d,f){if(d.isSigner!==f.isSigner)return d.isSigner?-1:1;if(d.isWritable!==f.isWritable)return d.isWritable?-1:1;const m={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return d.pubkey.toBase58().localeCompare(f.pubkey.toBase58(),"en",m)});const a=i.findIndex(d=>d.pubkey.equals(n));if(a>-1){const[d]=i.splice(a,1);d.isSigner=!0,d.isWritable=!0,i.unshift(d)}else i.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(const d of this.signatures){const f=i.findIndex(m=>m.pubkey.equals(d.publicKey));if(f>-1)i[f].isSigner||(i[f].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${d.publicKey.toString()}`)}let c=0,u=0,l=0;const h=[],w=[];i.forEach(({pubkey:d,isSigner:f,isWritable:m})=>{f?(h.push(d.toString()),c+=1,m||(u+=1)):(w.push(d.toString()),m||(l+=1))});const p=h.concat(w),y=t.map(d=>{const{data:f,programId:m}=d;return{programIdIndex:p.indexOf(m.toString()),accounts:d.keys.map(E=>p.indexOf(E.pubkey.toString())),data:Ne.encode(f)}});return y.forEach(d=>{se(d.programIdIndex>=0),d.accounts.forEach(f=>se(f>=0))}),new lt({header:{numRequiredSignatures:c,numReadonlySignedAccounts:u,numReadonlyUnsignedAccounts:l},accountKeys:p,recentBlockhash:e,instructions:y})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((r,o)=>t[o].equals(r.publicKey))||(this.signatures=t.map(n=>({signature:null,publicKey:n}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const t=new Set;this.signatures=e.filter(n=>{const r=n.toString();return t.has(r)?!1:(t.add(r),!0)}).map(n=>({signature:null,publicKey:n}))}sign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}this.signatures=n.map(o=>({signature:null,publicKey:o.publicKey}));const r=this._compile();this._partialSign(r,...n)}partialSign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}const r=this._compile();this._partialSign(r,...n)}_partialSign(e,...t){const n=e.serialize();t.forEach(r=>{const o=zr(n,r.secretKey);this._addSignature(r.publicKey,j(o))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){se(t.length===64);const n=this.signatures.findIndex(r=>e.equals(r.publicKey));if(n<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[n].signature=q.Buffer.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){const n={};for(const{signature:r,publicKey:o}of this.signatures)r===null?t&&(n.missing||(n.missing=[])).push(o):Bc(r,e,o.toBytes())||(n.invalid||(n.invalid=[])).push(o);return n.invalid||n.missing?n:void 0}serialize(e){const{requireAllSignatures:t,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),r=this.serializeMessage();if(n){const o=this._getMessageSignednessErrors(r,t);if(o){let i="Signature verification failed.";throw o.invalid&&(i+=`
Invalid signature for public key${o.invalid.length===1?"":"(s)"} [\`${o.invalid.map(a=>a.toBase58()).join("`, `")}\`].`),o.missing&&(i+=`
Missing signature for public key${o.missing.length===1?"":"(s)"} [\`${o.missing.map(a=>a.toBase58()).join("`, `")}\`].`),new Error(i)}}return this._serialize(r)}_serialize(e){const{signatures:t}=this,n=[];Ze(n,t.length);const r=n.length+t.length*64+e.length,o=q.Buffer.alloc(r);return se(t.length<256),q.Buffer.from(n).copy(o,0),t.forEach(({signature:i},a)=>{i!==null&&(se(i.length===64,"signature has invalid length"),q.Buffer.from(i).copy(o,n.length+a*64))}),e.copy(o,n.length+t.length*64),se(o.length<=Nt,`Transaction too large: ${o.length} > ${Nt}`),o}get keys(){return se(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return se(this.instructions.length===1),this.instructions[0].programId}get data(){return se(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e];const n=He(t);let r=[];for(let o=0;o<n;o++){const i=Ve(t,0,Ln);r.push(Ne.encode(q.Buffer.from(i)))}return ce.populate(lt.from(t),r)}static populate(e,t=[]){const n=new ce;return n.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(n.feePayer=e.accountKeys[0]),t.forEach((r,o)=>{const i={signature:r==Ne.encode(Oc)?null:Ne.decode(r),publicKey:e.accountKeys[o]};n.signatures.push(i)}),e.instructions.forEach(r=>{const o=r.accounts.map(i=>{const a=e.accountKeys[i];return{pubkey:a,isSigner:n.signatures.some(c=>c.publicKey.toString()===a.toString())||e.isAccountSigner(i),isWritable:e.isAccountWritable(i)}});n.instructions.push(new de({keys:o,programId:e.accountKeys[r.programIdIndex],data:Ne.decode(r.data)}))}),n._message=e,n._json=n.toJSON(),n}}class zo{constructor(e){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=e.payerKey,this.instructions=e.instructions,this.recentBlockhash=e.recentBlockhash}static decompile(e,t){const{header:n,compiledInstructions:r,recentBlockhash:o}=e,{numRequiredSignatures:i,numReadonlySignedAccounts:a,numReadonlyUnsignedAccounts:c}=n,u=i-a;se(u>0,"Message header is invalid");const l=e.staticAccountKeys.length-i-c;se(l>=0,"Message header is invalid");const h=e.getAccountKeys(t),w=h.get(0);if(w===void 0)throw new Error("Failed to decompile message because no account keys were found");const p=[];for(const y of r){const d=[];for(const m of y.accountKeyIndexes){const E=h.get(m);if(E===void 0)throw new Error(`Failed to find key for account key index ${m}`);const I=m<i;let C;I?C=m<u:m<h.staticAccountKeys.length?C=m-i<l:C=m-h.staticAccountKeys.length<h.accountKeysFromLookups.writable.length,d.push({pubkey:E,isSigner:m<n.numRequiredSignatures,isWritable:C})}const f=h.get(y.programIdIndex);if(f===void 0)throw new Error(`Failed to find program id for program id index ${y.programIdIndex}`);p.push(new de({programId:f,data:j(y.data),keys:d}))}return new zo({payerKey:w,instructions:p,recentBlockhash:o})}compileToLegacyMessage(){return lt.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(e){return Gt.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:e})}}class Uo{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,t!==void 0)se(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{const n=[];for(let r=0;r<e.header.numRequiredSignatures;r++)n.push(new Uint8Array(Ln));this.signatures=n}this.message=e}serialize(){const e=this.message.serialize(),t=Array();Ze(t,this.signatures.length);const n=z([ge(t.length,"encodedSignaturesLength"),Ue(Rc(),this.signatures.length,"signatures"),ge(e.length,"serializedMessage")]),r=new Uint8Array(2048),o=n.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},r);return r.slice(0,o)}static deserialize(e){let t=[...e];const n=[],r=He(t);for(let i=0;i<r;i++)n.push(new Uint8Array(Ve(t,0,Ln)));const o=No.deserialize(new Uint8Array(t));return new Uo(o,n)}sign(e){const t=this.message.serialize(),n=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const r of e){const o=n.findIndex(i=>i.equals(r.publicKey));se(o>=0,`Cannot sign with non signer key ${r.publicKey.toBase58()}`),this.signatures[o]=zr(t,r.secretKey)}}addSignature(e,t){se(t.byteLength===64,"Signature must be 64 bytes long");const r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(o=>o.equals(e));se(r>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[r]=t}}const Nc=160,zc=64,Uc=Nc/zc,Ko=1e3/Uc,pt=new x("SysvarC1ock11111111111111111111111111111111"),Wl=new x("SysvarEpochSchedu1e111111111111111111111111"),Fl=new x("Sysvar1nstructions1111111111111111111111111"),sr=new x("SysvarRecentB1ockHashes11111111111111111111"),hn=new x("SysvarRent111111111111111111111111111111111"),Dl=new x("SysvarRewards111111111111111111111111111111"),ql=new x("SysvarS1otHashes111111111111111111111111111"),$l=new x("SysvarS1otHistory11111111111111111111111111"),or=new x("SysvarStakeHistory1111111111111111111111111");class On extends Error{constructor({action:e,signature:t,transactionMessage:n,logs:r}){const o=r?`Logs: 
${JSON.stringify(r.slice(-10),null,2)}. `:"",i="\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";let a;switch(e){case"send":a=`Transaction ${t} resulted in an error. 
${n}. `+o+i;break;case"simulate":a=`Simulation failed. 
Message: ${n}. 
`+o+i;break;default:a=`Unknown action '${(c=>c)(e)}'`}super(a),this.signature=void 0,this.transactionMessage=void 0,this.transactionLogs=void 0,this.signature=t,this.transactionMessage=n,this.transactionLogs=r||void 0}get transactionError(){return{message:this.transactionMessage,logs:Array.isArray(this.transactionLogs)?this.transactionLogs:void 0}}get logs(){const e=this.transactionLogs;if(!(e!=null&&typeof e=="object"&&"then"in e))return e}async getLogs(e){return Array.isArray(this.transactionLogs)||(this.transactionLogs=new Promise((t,n)=>{e.getTransaction(this.signature).then(r=>{if(r&&r.meta&&r.meta.logMessages){const o=r.meta.logMessages;this.transactionLogs=o,t(o)}else n(new Error("Log messages not found"))}).catch(n)})),await this.transactionLogs}}const Ml={JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP:-32001,JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE:-32002,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:-32003,JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE:-32004,JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY:-32005,JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:-32006,JSON_RPC_SERVER_ERROR_SLOT_SKIPPED:-32007,JSON_RPC_SERVER_ERROR_NO_SNAPSHOT:-32008,JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:-32009,JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:-32010,JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE:-32011,JSON_RPC_SCAN_ERROR:-32012,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH:-32013,JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:-32014,JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:-32015,JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED:-32016};class W extends Error{constructor({code:e,message:t,data:n},r){super(r!=null?`${r}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=n,this.name="SolanaJSONRPCError"}}async function ps(s,e,t,n){const r=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment,maxRetries:n.maxRetries,minContextSlot:n.minContextSlot},o=await s.sendTransaction(e,t,r);let i;if(e.recentBlockhash!=null&&e.lastValidBlockHeight!=null)i=(await s.confirmTransaction({abortSignal:n==null?void 0:n.abortSignal,signature:o,blockhash:e.recentBlockhash,lastValidBlockHeight:e.lastValidBlockHeight},n&&n.commitment)).value;else if(e.minNonceContextSlot!=null&&e.nonceInfo!=null){const{nonceInstruction:a}=e.nonceInfo,c=a.keys[0].pubkey;i=(await s.confirmTransaction({abortSignal:n==null?void 0:n.abortSignal,minContextSlot:e.minNonceContextSlot,nonceAccountPubkey:c,nonceValue:e.nonceInfo.nonce,signature:o},n&&n.commitment)).value}else(n==null?void 0:n.abortSignal)!=null&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),i=(await s.confirmTransaction(o,n&&n.commitment)).value;if(i.err)throw o!=null?new On({action:"send",signature:o,transactionMessage:`Status: (${JSON.stringify(i)})`}):new Error(`Transaction ${o} failed (${JSON.stringify(i)})`);return o}function Tt(s){return new Promise(e=>setTimeout(e,s))}function ee(s,e){const t=s.layout.span>=0?s.layout.span:Co(s,e),n=q.Buffer.alloc(t),r=Object.assign({instruction:s.index},e);return s.layout.encode(r,n),n}function ae(s,e){let t;try{t=s.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.instruction!==s.index)throw new Error(`invalid instruction; instruction index mismatch ${t.instruction} != ${s.index}`);return t}const Kc=Le("lamportsPerSignature"),Wo=z([N("version"),N("state"),X("authorizedPubkey"),X("nonce"),z([Kc],"feeCalculator")]),ys=Wo.span;class Kr{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=Wo.decode(j(e),0);return new Kr({authorizedPubkey:new x(t.authorizedPubkey),nonce:new x(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const Wc=s=>{const e=s.decode.bind(s),t=s.encode.bind(s);return{decode:e,encode:t}},Fc=s=>e=>{const t=ge(s,e),{encode:n,decode:r}=Wc(t),o=t;return o.decode=(i,a)=>{const c=r(i,a);return Oa(q.Buffer.from(c))},o.encode=(i,a,c)=>{const u=wo(i,s);return n(u,a,c)},o},Yt=Fc(8);class Hl{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=N("instruction").decode(e.data);let r;for(const[o,i]of Object.entries(fe))if(i.index==n){r=o;break}if(!r)throw new Error("Instruction type incorrect; not a SystemInstruction");return r}static decodeCreateAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t,space:n,programId:r}=ae(fe.Create,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,lamports:t,space:n,programId:new x(r)}}static decodeTransfer(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t}=ae(fe.Transfer,e.data);return{fromPubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,lamports:t}}static decodeTransferWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t,seed:n,programId:r}=ae(fe.TransferWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,basePubkey:e.keys[1].pubkey,toPubkey:e.keys[2].pubkey,lamports:t,seed:n,programId:new x(r)}}static decodeAllocate(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{space:t}=ae(fe.Allocate,e.data);return{accountPubkey:e.keys[0].pubkey,space:t}}static decodeAllocateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:n,space:r,programId:o}=ae(fe.AllocateWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new x(t),seed:n,space:r,programId:new x(o)}}static decodeAssign(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{programId:t}=ae(fe.Assign,e.data);return{accountPubkey:e.keys[0].pubkey,programId:new x(t)}}static decodeAssignWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:n,programId:r}=ae(fe.AssignWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new x(t),seed:n,programId:new x(r)}}static decodeCreateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{base:t,seed:n,lamports:r,space:o,programId:i}=ae(fe.CreateWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,basePubkey:new x(t),seed:n,lamports:r,space:o,programId:new x(i)}}static decodeNonceInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{authorized:t}=ae(fe.InitializeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:new x(t)}}static decodeNonceAdvance(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),ae(fe.AdvanceNonceAccount,e.data),{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static decodeNonceWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=ae(fe.WithdrawNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t}}static decodeNonceAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t}=ae(fe.AuthorizeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[1].pubkey,newAuthorizedPubkey:new x(t)}}static checkProgramId(e){if(!e.equals(ze.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const fe=Object.freeze({Create:{index:0,layout:z([N("instruction"),Ye("lamports"),Ye("space"),X("programId")])},Assign:{index:1,layout:z([N("instruction"),X("programId")])},Transfer:{index:2,layout:z([N("instruction"),Yt("lamports")])},CreateWithSeed:{index:3,layout:z([N("instruction"),X("base"),Ct("seed"),Ye("lamports"),Ye("space"),X("programId")])},AdvanceNonceAccount:{index:4,layout:z([N("instruction")])},WithdrawNonceAccount:{index:5,layout:z([N("instruction"),Ye("lamports")])},InitializeNonceAccount:{index:6,layout:z([N("instruction"),X("authorized")])},AuthorizeNonceAccount:{index:7,layout:z([N("instruction"),X("authorized")])},Allocate:{index:8,layout:z([N("instruction"),Ye("space")])},AllocateWithSeed:{index:9,layout:z([N("instruction"),X("base"),Ct("seed"),Ye("space"),X("programId")])},AssignWithSeed:{index:10,layout:z([N("instruction"),X("base"),Ct("seed"),X("programId")])},TransferWithSeed:{index:11,layout:z([N("instruction"),Yt("lamports"),Ct("seed"),X("programId")])},UpgradeNonceAccount:{index:12,layout:z([N("instruction")])}});class ze{constructor(){}static createAccount(e){const t=fe.Create,n=ee(t,{lamports:e.lamports,space:e.space,programId:j(e.programId.toBuffer())});return new de({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:n})}static transfer(e){let t,n;if("basePubkey"in e){const r=fe.TransferWithSeed;t=ee(r,{lamports:BigInt(e.lamports),seed:e.seed,programId:j(e.programId.toBuffer())}),n=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{const r=fe.Transfer;t=ee(r,{lamports:BigInt(e.lamports)}),n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new de({keys:n,programId:this.programId,data:t})}static assign(e){let t,n;if("basePubkey"in e){const r=fe.AssignWithSeed;t=ee(r,{base:j(e.basePubkey.toBuffer()),seed:e.seed,programId:j(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const r=fe.Assign;t=ee(r,{programId:j(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new de({keys:n,programId:this.programId,data:t})}static createAccountWithSeed(e){const t=fe.CreateWithSeed,n=ee(t,{base:j(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:j(e.programId.toBuffer())});let r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey!=e.fromPubkey&&r.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new de({keys:r,programId:this.programId,data:n})}static createNonceAccount(e){const t=new ce;"basePubkey"in e&&"seed"in e?t.add(ze.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:ys,programId:this.programId})):t.add(ze.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:ys,programId:this.programId}));const n={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(n)),t}static nonceInitialize(e){const t=fe.InitializeNonceAccount,n=ee(t,{authorized:j(e.authorizedPubkey.toBuffer())}),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:sr,isSigner:!1,isWritable:!1},{pubkey:hn,isSigner:!1,isWritable:!1}],programId:this.programId,data:n};return new de(r)}static nonceAdvance(e){const t=fe.AdvanceNonceAccount,n=ee(t),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:sr,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n};return new de(r)}static nonceWithdraw(e){const t=fe.WithdrawNonceAccount,n=ee(t,{lamports:e.lamports});return new de({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:sr,isSigner:!1,isWritable:!1},{pubkey:hn,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static nonceAuthorize(e){const t=fe.AuthorizeNonceAccount,n=ee(t,{authorized:j(e.newAuthorizedPubkey.toBuffer())});return new de({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static allocate(e){let t,n;if("basePubkey"in e){const r=fe.AllocateWithSeed;t=ee(r,{base:j(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:j(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const r=fe.Allocate;t=ee(r,{space:e.space}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new de({keys:n,programId:this.programId,data:t})}}ze.programId=new x("11111111111111111111111111111111");const Dc=Nt-300;class Zt{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/Zt.chunkSize)+1+1)}static async load(e,t,n,r,o){{const h=await e.getMinimumBalanceForRentExemption(o.length),w=await e.getAccountInfo(n.publicKey,"confirmed");let p=null;if(w!==null){if(w.executable)return console.error("Program load failed, account is already executable"),!1;w.data.length!==o.length&&(p=p||new ce,p.add(ze.allocate({accountPubkey:n.publicKey,space:o.length}))),w.owner.equals(r)||(p=p||new ce,p.add(ze.assign({accountPubkey:n.publicKey,programId:r}))),w.lamports<h&&(p=p||new ce,p.add(ze.transfer({fromPubkey:t.publicKey,toPubkey:n.publicKey,lamports:h-w.lamports})))}else p=new ce().add(ze.createAccount({fromPubkey:t.publicKey,newAccountPubkey:n.publicKey,lamports:h>0?h:1,space:o.length,programId:r}));p!==null&&await ps(e,p,[t,n],{commitment:"confirmed"})}const i=z([N("instruction"),N("offset"),N("bytesLength"),N("bytesLengthPadding"),Ue(te("byte"),Bt(N(),-8),"bytes")]),a=Zt.chunkSize;let c=0,u=o,l=[];for(;u.length>0;){const h=u.slice(0,a),w=q.Buffer.alloc(a+16);i.encode({instruction:0,offset:c,bytes:h,bytesLength:0,bytesLengthPadding:0},w);const p=new ce().add({keys:[{pubkey:n.publicKey,isSigner:!0,isWritable:!0}],programId:r,data:w});l.push(ps(e,p,[t,n],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")&&await Tt(1e3/4),c+=a,u=u.slice(a)}await Promise.all(l);{const h=z([N("instruction")]),w=q.Buffer.alloc(h.span);h.encode({instruction:1},w);const p=new ce().add({keys:[{pubkey:n.publicKey,isSigner:!0,isWritable:!0},{pubkey:hn,isSigner:!1,isWritable:!1}],programId:r,data:w}),y="processed",d=await e.sendTransaction(p,[t,n],{preflightCommitment:y}),{context:f,value:m}=await e.confirmTransaction({signature:d,lastValidBlockHeight:p.lastValidBlockHeight,blockhash:p.recentBlockhash},y);if(m.err)throw new Error(`Transaction ${d} failed (${JSON.stringify(m)})`);for(;;){try{if(await e.getSlot({commitment:y})>f.slot)break}catch{}await new Promise(E=>setTimeout(E,Math.round(Ko/2)))}}return!0}}Zt.chunkSize=Dc;const Vl=new x("BPFLoader2111111111111111111111111111111111");class jl{static getMinNumSignatures(e){return Zt.getMinNumSignatures(e)}static load(e,t,n,r,o){return Zt.load(e,t,n,o,r)}}function qc(s){return s&&s.__esModule&&Object.prototype.hasOwnProperty.call(s,"default")?s.default:s}var $c=Object.prototype.toString,Mc=Object.keys||function(s){var e=[];for(var t in s)e.push(t);return e};function an(s,e){var t,n,r,o,i,a,c;if(s===!0)return"true";if(s===!1)return"false";switch(typeof s){case"object":if(s===null)return null;if(s.toJSON&&typeof s.toJSON=="function")return an(s.toJSON(),e);if(c=$c.call(s),c==="[object Array]"){for(r="[",n=s.length-1,t=0;t<n;t++)r+=an(s[t],!0)+",";return n>-1&&(r+=an(s[t],!0)),r+"]"}else if(c==="[object Object]"){for(o=Mc(s).sort(),n=o.length,r="",t=0;t<n;)i=o[t],a=an(s[i],!1),a!==void 0&&(r&&(r+=","),r+=JSON.stringify(i)+":"+a),t++;return"{"+r+"}"}else return JSON.stringify(s);case"function":case"undefined":return e?null:void 0;case"string":return JSON.stringify(s);default:return isFinite(s)?s:null}}var Hc=function(s){var e=an(s,!1);if(e!==void 0)return""+e},bs=qc(Hc);const sn=32;function ir(s){let e=0;for(;s>1;)s/=2,e++;return e}function Vc(s){return s===0?1:(s--,s|=s>>1,s|=s>>2,s|=s>>4,s|=s>>8,s|=s>>16,s|=s>>32,s+1)}class jc{constructor(e,t,n,r,o){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=n,this.firstNormalEpoch=r,this.firstNormalSlot=o}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=ir(Vc(e+sn+1))-ir(sn)-1,n=this.getSlotsInEpoch(t),r=e-(n-sn);return[t,r]}else{const t=e-this.firstNormalSlot,n=Math.floor(t/this.slotsPerEpoch),r=this.firstNormalEpoch+n,o=t%this.slotsPerEpoch;return[r,o]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*sn:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+ir(sn)):this.slotsPerEpoch}}var Gc=globalThis.fetch;class Yc extends Ic{constructor(e,t,n){const r=o=>{const i=kc(o,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in i?this.underlyingSocket=i.socket:this.underlyingSocket=i,i};super(r,e,t,n),this.underlyingSocket=void 0}call(...e){var n;const t=(n=this.underlyingSocket)==null?void 0:n.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){var n;const t=(n=this.underlyingSocket)==null?void 0:n.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}}function Zc(s,e){let t;try{t=s.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.typeIndex!==s.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${s.index}`);return t}const ms=56;class ws{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=Zc(Jc,e),n=e.length-ms;se(n>=0,"lookup table is invalid"),se(n%32===0,"lookup table is invalid");const r=n/32,{addresses:o}=z([Ue(X(),r,"addresses")]).decode(e.slice(ms));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new x(t.authority[0]):void 0,addresses:o.map(i=>new x(i))}}}const Jc={index:1,layout:z([N("typeIndex"),Yt("deactivationSlot"),Le("lastExtendedSlot"),te("lastExtendedStartIndex"),te(),Ue(X(),Bt(te(),-1),"authority")])},Xc=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function Qc(s){const e=s.match(Xc);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${s}\``);const[t,n,r,o]=e,i=s.startsWith("https:")?"wss:":"ws:",a=r==null?null:parseInt(r.slice(1),10),c=a==null?"":`:${a+1}`;return`${i}//${n}${c}${o}`}const me=mn(Or(x),A(),s=>new x(s)),Fo=Nr([A(),ye("base64")]),Wr=mn(Or(q.Buffer),Fo,s=>q.Buffer.from(s[0],"base64")),eu=30*1e3;function tu(s){if(/^https?:/.test(s)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return s}function le(s){let e,t;if(typeof s=="string")e=s;else if(s){const{commitment:n,...r}=s;e=n,t=r}return{commitment:e,config:t}}function ks(s){return s.map(e=>"memcmp"in e?{...e,memcmp:{...e.memcmp,encoding:e.memcmp.encoding??"base58"}}:e)}function Do(s){return Me([S({jsonrpc:ye("2.0"),id:A(),result:s}),S({jsonrpc:ye("2.0"),id:A(),error:S({code:tn(),message:A(),data:$($a())})})])}const nu=Do(tn());function V(s){return mn(Do(s),nu,e=>"error"in e?e:{...e,result:B(e.result,s)})}function Se(s){return V(S({context:S({slot:g()}),value:s}))}function Hn(s){return S({context:S({slot:g()}),value:s})}function ar(s,e){return s===0?new Gt({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new x(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:Ne.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new lt(e)}const ru=S({foundation:g(),foundationTerm:g(),initial:g(),taper:g(),terminal:g()}),su=V(P(T(S({epoch:g(),effectiveSlot:g(),amount:g(),postBalance:g(),commission:$(T(g()))})))),ou=P(S({slot:g(),prioritizationFee:g()})),iu=S({total:g(),validator:g(),foundation:g(),epoch:g()}),au=S({epoch:g(),slotIndex:g(),slotsInEpoch:g(),absoluteSlot:g(),blockHeight:$(g()),transactionCount:$(g())}),cu=S({slotsPerEpoch:g(),leaderScheduleSlotOffset:g(),warmup:ut(),firstNormalEpoch:g(),firstNormalSlot:g()}),uu=Io(A(),P(g())),Dt=T(Me([S({}),A()])),lu=S({err:Dt}),du=ye("receivedSignature"),hu=S({"solana-core":A(),"feature-set":$(g())}),fu=S({program:A(),programId:me,parsed:tn()}),gu=S({programId:me,accounts:P(me),data:A()}),Ss=Se(S({err:T(Me([S({}),A()])),logs:T(P(A())),accounts:$(T(P(T(S({executable:ut(),owner:A(),lamports:g(),data:P(A()),rentEpoch:$(g())}))))),unitsConsumed:$(g()),returnData:$(T(S({programId:A(),data:Nr([A(),ye("base64")])}))),innerInstructions:$(T(P(S({index:g(),instructions:P(Me([fu,gu]))}))))})),pu=Se(S({byIdentity:Io(A(),P(g())),range:S({firstSlot:g(),lastSlot:g()})}));function yu(s,e,t,n,r,o){const i=t||Gc;let a;o!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return n&&(c=async(l,h)=>{const w=await new Promise((p,y)=>{try{n(l,h,(d,f)=>p([d,f]))}catch(d){y(d)}});return await i(...w)}),new mc(async(l,h)=>{const w={method:"POST",body:l,agent:a,headers:Object.assign({"Content-Type":"application/json"},e||{},bl)};try{let p=5,y,d=500;for(;c?y=await c(s,w):y=await i(s,w),!(y.status!==429||r===!0||(p-=1,p===0));)console.error(`Server responded with ${y.status} ${y.statusText}.  Retrying after ${d}ms delay...`),await Tt(d),d*=2;const f=await y.text();y.ok?h(null,f):h(new Error(`${y.status} ${y.statusText}: ${f}`))}catch(p){p instanceof Error&&h(p)}},{})}function bu(s){return(e,t)=>new Promise((n,r)=>{s.request(e,t,(o,i)=>{if(o){r(o);return}n(i)})})}function mu(s){return e=>new Promise((t,n)=>{e.length===0&&t([]);const r=e.map(o=>s.request(o.methodName,o.args));s.request(r,(o,i)=>{if(o){n(o);return}t(i)})})}const wu=V(ru),ku=V(iu),Su=V(ou),Iu=V(au),Eu=V(cu),Au=V(uu),_u=V(g()),Bu=Se(S({total:g(),circulating:g(),nonCirculating:g(),nonCirculatingAccounts:P(me)})),br=S({amount:A(),uiAmount:T(g()),decimals:g(),uiAmountString:$(A())}),xu=Se(P(S({address:me,amount:A(),uiAmount:T(g()),decimals:g(),uiAmountString:$(A())}))),vu=Se(P(S({pubkey:me,account:S({executable:ut(),owner:me,lamports:g(),data:Wr,rentEpoch:g()})}))),mr=S({program:A(),parsed:tn(),space:g()}),Ru=Se(P(S({pubkey:me,account:S({executable:ut(),owner:me,lamports:g(),data:mr,rentEpoch:g()})}))),Pu=Se(P(S({lamports:g(),address:me}))),fn=S({executable:ut(),owner:me,lamports:g(),data:Wr,rentEpoch:g()}),Tu=S({pubkey:me,account:fn}),Lu=mn(Me([Or(q.Buffer),mr]),Me([Fo,mr]),s=>Array.isArray(s)?B(s,Wr):s),wr=S({executable:ut(),owner:me,lamports:g(),data:Lu,rentEpoch:g()}),Cu=S({pubkey:me,account:wr}),Ou=S({state:Me([ye("active"),ye("inactive"),ye("activating"),ye("deactivating")]),active:g(),inactive:g()}),Nu=V(P(S({signature:A(),slot:g(),err:Dt,memo:T(A()),blockTime:$(T(g()))}))),zu=V(P(S({signature:A(),slot:g(),err:Dt,memo:T(A()),blockTime:$(T(g()))}))),Uu=S({subscription:g(),result:Hn(fn)}),Ku=S({pubkey:me,account:fn}),Wu=S({subscription:g(),result:Hn(Ku)}),Fu=S({parent:g(),slot:g(),root:g()}),Du=S({subscription:g(),result:Fu}),qu=Me([S({type:Me([ye("firstShredReceived"),ye("completed"),ye("optimisticConfirmation"),ye("root")]),slot:g(),timestamp:g()}),S({type:ye("createdBank"),parent:g(),slot:g(),timestamp:g()}),S({type:ye("frozen"),slot:g(),timestamp:g(),stats:S({numTransactionEntries:g(),numSuccessfulTransactions:g(),numFailedTransactions:g(),maxTransactionsPerEntry:g()})}),S({type:ye("dead"),slot:g(),timestamp:g(),err:A()})]),$u=S({subscription:g(),result:qu}),Mu=S({subscription:g(),result:Hn(Me([lu,du]))}),Hu=S({subscription:g(),result:g()}),Vu=S({pubkey:A(),gossip:T(A()),tpu:T(A()),rpc:T(A()),version:T(A())}),Is=S({votePubkey:A(),nodePubkey:A(),activatedStake:g(),epochVoteAccount:ut(),epochCredits:P(Nr([g(),g(),g()])),commission:g(),lastVote:g(),rootSlot:T(g())}),ju=V(S({current:P(Is),delinquent:P(Is)})),Gu=Me([ye("processed"),ye("confirmed"),ye("finalized")]),Yu=S({slot:g(),confirmations:T(g()),err:Dt,confirmationStatus:$(Gu)}),Zu=Se(P(T(Yu))),Ju=V(g()),qo=S({accountKey:me,writableIndexes:P(g()),readonlyIndexes:P(g())}),Fr=S({signatures:P(A()),message:S({accountKeys:P(A()),header:S({numRequiredSignatures:g(),numReadonlySignedAccounts:g(),numReadonlyUnsignedAccounts:g()}),instructions:P(S({accounts:P(g()),data:A(),programIdIndex:g()})),recentBlockhash:A(),addressTableLookups:$(P(qo))})}),$o=S({pubkey:me,signer:ut(),writable:ut(),source:$(Me([ye("transaction"),ye("lookupTable")]))}),Mo=S({accountKeys:P($o),signatures:P(A())}),Ho=S({parsed:tn(),program:A(),programId:me}),Vo=S({accounts:P(me),data:A(),programId:me}),Xu=Me([Vo,Ho]),Qu=Me([S({parsed:tn(),program:A(),programId:A()}),S({accounts:P(A()),data:A(),programId:A()})]),jo=mn(Xu,Qu,s=>"accounts"in s?B(s,Vo):B(s,Ho)),Go=S({signatures:P(A()),message:S({accountKeys:P($o),instructions:P(jo),recentBlockhash:A(),addressTableLookups:$(T(P(qo)))})}),Nn=S({accountIndex:g(),mint:A(),owner:$(A()),uiTokenAmount:br}),Yo=S({writable:P(me),readonly:P(me)}),Vn=S({err:Dt,fee:g(),innerInstructions:$(T(P(S({index:g(),instructions:P(S({accounts:P(g()),data:A(),programIdIndex:g()}))})))),preBalances:P(g()),postBalances:P(g()),logMessages:$(T(P(A()))),preTokenBalances:$(T(P(Nn))),postTokenBalances:$(T(P(Nn))),loadedAddresses:$(Yo),computeUnitsConsumed:$(g())}),Dr=S({err:Dt,fee:g(),innerInstructions:$(T(P(S({index:g(),instructions:P(jo)})))),preBalances:P(g()),postBalances:P(g()),logMessages:$(T(P(A()))),preTokenBalances:$(T(P(Nn))),postTokenBalances:$(T(P(Nn))),loadedAddresses:$(Yo),computeUnitsConsumed:$(g())}),nn=Me([ye(0),ye("legacy")]),qt=S({pubkey:A(),lamports:g(),postBalance:T(g()),rewardType:T(A()),commission:$(T(g()))}),el=V(T(S({blockhash:A(),previousBlockhash:A(),parentSlot:g(),transactions:P(S({transaction:Fr,meta:T(Vn),version:$(nn)})),rewards:$(P(qt)),blockTime:T(g()),blockHeight:T(g())}))),tl=V(T(S({blockhash:A(),previousBlockhash:A(),parentSlot:g(),rewards:$(P(qt)),blockTime:T(g()),blockHeight:T(g())}))),nl=V(T(S({blockhash:A(),previousBlockhash:A(),parentSlot:g(),transactions:P(S({transaction:Mo,meta:T(Vn),version:$(nn)})),rewards:$(P(qt)),blockTime:T(g()),blockHeight:T(g())}))),rl=V(T(S({blockhash:A(),previousBlockhash:A(),parentSlot:g(),transactions:P(S({transaction:Go,meta:T(Dr),version:$(nn)})),rewards:$(P(qt)),blockTime:T(g()),blockHeight:T(g())}))),sl=V(T(S({blockhash:A(),previousBlockhash:A(),parentSlot:g(),transactions:P(S({transaction:Mo,meta:T(Dr),version:$(nn)})),rewards:$(P(qt)),blockTime:T(g()),blockHeight:T(g())}))),ol=V(T(S({blockhash:A(),previousBlockhash:A(),parentSlot:g(),rewards:$(P(qt)),blockTime:T(g()),blockHeight:T(g())}))),il=V(T(S({blockhash:A(),previousBlockhash:A(),parentSlot:g(),transactions:P(S({transaction:Fr,meta:T(Vn)})),rewards:$(P(qt)),blockTime:T(g())}))),Es=V(T(S({blockhash:A(),previousBlockhash:A(),parentSlot:g(),signatures:P(A()),blockTime:T(g())}))),cr=V(T(S({slot:g(),meta:T(Vn),blockTime:$(T(g())),transaction:Fr,version:$(nn)}))),En=V(T(S({slot:g(),transaction:Go,meta:T(Dr),blockTime:$(T(g())),version:$(nn)}))),al=Se(S({blockhash:A(),feeCalculator:S({lamportsPerSignature:g()})})),cl=Se(S({blockhash:A(),lastValidBlockHeight:g()})),ul=Se(ut()),ll=S({slot:g(),numTransactions:g(),numSlots:g(),samplePeriodSecs:g()}),dl=V(P(ll)),hl=Se(T(S({feeCalculator:S({lamportsPerSignature:g()})}))),fl=V(A()),gl=V(A()),pl=S({err:Dt,logs:P(A()),signature:A()}),yl=S({result:Hn(pl),subscription:g()}),bl={"solana-client":"js/0.0.0-development"};class Gl{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const u={};return async l=>{const{commitment:h,config:w}=le(l),p=this._buildArgs([],h,void 0,w),y=bs(p);return u[y]=u[y]??(async()=>{try{const d=await this._rpcRequest("getBlockHeight",p),f=B(d,V(g()));if("error"in f)throw new W(f.error,"failed to get block height information");return f.result}finally{delete u[y]}})(),await u[y]}})();let n,r,o,i,a,c;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,n=t.wsEndpoint,r=t.httpHeaders,o=t.fetch,i=t.fetchMiddleware,a=t.disableRetryOnRateLimit,c=t.httpAgent),this._rpcEndpoint=tu(e),this._rpcWsEndpoint=n||Qc(e),this._rpcClient=yu(e,r,o,i,a,c),this._rpcRequest=bu(this._rpcClient),this._rpcBatchRequest=mu(this._rpcClient),this._rpcWebSocket=new Yc(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:n,config:r}=le(t),o=this._buildArgs([e.toBase58()],n,void 0,r),i=await this._rpcRequest("getBalance",o),a=B(i,Se(g()));if("error"in a)throw new W(a.error,`failed to get balance for ${e.toBase58()}`);return a.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+n)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),n=B(t,V(T(g())));if("error"in n)throw new W(n.error,`failed to get block time for slot ${e}`);return n.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=B(e,V(g()));if("error"in t)throw new W(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=B(e,_u);if("error"in t)throw new W(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};typeof e=="string"?t={commitment:e}:e?t={...e,commitment:e&&e.commitment||this.commitment}:t={commitment:this.commitment};const n=await this._rpcRequest("getSupply",[t]),r=B(n,Bu);if("error"in r)throw new W(r.error,"failed to get supply");return r.result}async getTokenSupply(e,t){const n=this._buildArgs([e.toBase58()],t),r=await this._rpcRequest("getTokenSupply",n),o=B(r,Se(br));if("error"in o)throw new W(o.error,"failed to get token supply");return o.result}async getTokenAccountBalance(e,t){const n=this._buildArgs([e.toBase58()],t),r=await this._rpcRequest("getTokenAccountBalance",n),o=B(r,Se(br));if("error"in o)throw new W(o.error,"failed to get token account balance");return o.result}async getTokenAccountsByOwner(e,t,n){const{commitment:r,config:o}=le(n);let i=[e.toBase58()];"mint"in t?i.push({mint:t.mint.toBase58()}):i.push({programId:t.programId.toBase58()});const a=this._buildArgs(i,r,"base64",o),c=await this._rpcRequest("getTokenAccountsByOwner",a),u=B(c,vu);if("error"in u)throw new W(u.error,`failed to get token accounts owned by account ${e.toBase58()}`);return u.result}async getParsedTokenAccountsByOwner(e,t,n){let r=[e.toBase58()];"mint"in t?r.push({mint:t.mint.toBase58()}):r.push({programId:t.programId.toBase58()});const o=this._buildArgs(r,n,"jsonParsed"),i=await this._rpcRequest("getTokenAccountsByOwner",o),a=B(i,Ru);if("error"in a)throw new W(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},n=t.filter||t.commitment?[t]:[],r=await this._rpcRequest("getLargestAccounts",n),o=B(r,Pu);if("error"in o)throw new W(o.error,"failed to get largest accounts");return o.result}async getTokenLargestAccounts(e,t){const n=this._buildArgs([e.toBase58()],t),r=await this._rpcRequest("getTokenLargestAccounts",n),o=B(r,xu);if("error"in o)throw new W(o.error,"failed to get token largest accounts");return o.result}async getAccountInfoAndContext(e,t){const{commitment:n,config:r}=le(t),o=this._buildArgs([e.toBase58()],n,"base64",r),i=await this._rpcRequest("getAccountInfo",o),a=B(i,Se(T(fn)));if("error"in a)throw new W(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getParsedAccountInfo(e,t){const{commitment:n,config:r}=le(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",r),i=await this._rpcRequest("getAccountInfo",o),a=B(i,Se(T(wr)));if("error"in a)throw new W(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(n){throw new Error("failed to get info about account "+e.toBase58()+": "+n)}}async getMultipleParsedAccounts(e,t){const{commitment:n,config:r}=le(t),o=e.map(u=>u.toBase58()),i=this._buildArgs([o],n,"jsonParsed",r),a=await this._rpcRequest("getMultipleAccounts",i),c=B(a,Se(P(T(wr))));if("error"in c)throw new W(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:n,config:r}=le(t),o=e.map(u=>u.toBase58()),i=this._buildArgs([o],n,"base64",r),a=await this._rpcRequest("getMultipleAccounts",i),c=B(a,Se(P(T(fn))));if("error"in c)throw new W(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,n){const{commitment:r,config:o}=le(t),i=this._buildArgs([e.toBase58()],r,void 0,{...o,epoch:n??(o==null?void 0:o.epoch)}),a=await this._rpcRequest("getStakeActivation",i),c=B(a,V(Ou));if("error"in c)throw new W(c.error,`failed to get Stake Activation ${e.toBase58()}`);return c.result}async getProgramAccounts(e,t){const{commitment:n,config:r}=le(t),{encoding:o,...i}=r||{},a=this._buildArgs([e.toBase58()],n,o||"base64",{...i,...i.filters?{filters:ks(i.filters)}:null}),c=await this._rpcRequest("getProgramAccounts",a),u=P(Tu),l=i.withContext===!0?B(c,Se(u)):B(c,V(u));if("error"in l)throw new W(l.error,`failed to get accounts owned by program ${e.toBase58()}`);return l.result}async getParsedProgramAccounts(e,t){const{commitment:n,config:r}=le(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",r),i=await this._rpcRequest("getProgramAccounts",o),a=B(i,V(P(Cu)));if("error"in a)throw new W(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result}async confirmTransaction(e,t){var o;let n;if(typeof e=="string")n=e;else{const i=e;if((o=i.abortSignal)!=null&&o.aborted)return Promise.reject(i.abortSignal.reason);n=i.signature}let r;try{r=Ne.decode(n)}catch{throw new Error("signature must be base58 encoded: "+n)}return se(r.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:n}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,n)=>{e!=null&&(e.aborted?n(e.reason):e.addEventListener("abort",()=>{n(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let n,r,o=!1;const i=new Promise((c,u)=>{try{n=this.onSignature(t,(h,w)=>{n=void 0;const p={context:w,value:h};c({__type:It.PROCESSED,response:p})},e);const l=new Promise(h=>{n==null?h():r=this._onSubscriptionStateChange(n,w=>{w==="subscribed"&&h()})});(async()=>{if(await l,o)return;const h=await this.getSignatureStatus(t);if(o||h==null)return;const{context:w,value:p}=h;if(p!=null)if(p!=null&&p.err)u(p.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(p.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(p.confirmationStatus==="processed"||p.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}o=!0,c({__type:It.PROCESSED,response:{context:w,value:p}})}})()}catch(l){u(l)}});return{abortConfirmation:()=>{r&&(r(),r=void 0),n!=null&&(this.removeSignatureListener(n),n=void 0)},confirmationPromise:i}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:n,signature:r}}){let o=!1;const i=new Promise(h=>{const w=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let p=await w();if(!o){for(;p<=n;)if(await Tt(1e3),o||(p=await w(),o))return;h({__type:It.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:c}=this.getTransactionConfirmationPromise({commitment:e,signature:r}),u=this.getCancellationPromise(t);let l;try{const h=await Promise.race([u,c,i]);if(h.__type===It.PROCESSED)l=h.response;else throw new To(r)}finally{o=!0,a()}return l}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:n,nonceAccountPubkey:r,nonceValue:o,signature:i}}){let a=!1;const c=new Promise(p=>{let y=o,d=null;const f=async()=>{try{const{context:m,value:E}=await this.getNonceAndContext(r,{commitment:e,minContextSlot:n});return d=m.slot,E==null?void 0:E.nonce}catch{return y}};(async()=>{if(y=await f(),!a)for(;;){if(o!==y){p({__type:It.NONCE_INVALID,slotInWhichNonceDidAdvance:d});return}if(await Tt(2e3),a||(y=await f(),a))return}})()}),{abortConfirmation:u,confirmationPromise:l}=this.getTransactionConfirmationPromise({commitment:e,signature:i}),h=this.getCancellationPromise(t);let w;try{const p=await Promise.race([h,l,c]);if(p.__type===It.PROCESSED)w=p.response;else{let y;for(;;){const d=await this.getSignatureStatus(i);if(d==null)break;if(d.context.slot<(p.slotInWhichNonceDidAdvance??n)){await Tt(400);continue}y=d;break}if(y!=null&&y.value){const d=e||"finalized",{confirmationStatus:f}=y.value;switch(d){case"processed":case"recent":if(f!=="processed"&&f!=="confirmed"&&f!=="finalized")throw new on(i);break;case"confirmed":case"single":case"singleGossip":if(f!=="confirmed"&&f!=="finalized")throw new on(i);break;case"finalized":case"max":case"root":if(f!=="finalized")throw new on(i);break;default:}w={context:y.context,value:{err:y.value.err}}}else throw new on(i)}}finally{a=!0,u()}return w}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let n;const r=new Promise(c=>{let u=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{u=this._confirmTransactionInitialTimeout||3e4;break}}n=setTimeout(()=>c({__type:It.TIMED_OUT,timeoutMs:u}),u)}),{abortConfirmation:o,confirmationPromise:i}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let a;try{const c=await Promise.race([i,r]);if(c.__type===It.PROCESSED)a=c.response;else throw new Lo(t,c.timeoutMs/1e3)}finally{clearTimeout(n),o()}return a}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=B(e,V(P(Vu)));if("error"in t)throw new W(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getVoteAccounts",t),r=B(n,ju);if("error"in r)throw new W(r.error,"failed to get vote accounts");return r.result}async getSlot(e){const{commitment:t,config:n}=le(e),r=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getSlot",r),i=B(o,V(g()));if("error"in i)throw new W(i.error,"failed to get slot");return i.result}async getSlotLeader(e){const{commitment:t,config:n}=le(e),r=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getSlotLeader",r),i=B(o,V(A()));if("error"in i)throw new W(i.error,"failed to get slot leader");return i.result}async getSlotLeaders(e,t){const n=[e,t],r=await this._rpcRequest("getSlotLeaders",n),o=B(r,V(P(me)));if("error"in o)throw new W(o.error,"failed to get slot leaders");return o.result}async getSignatureStatus(e,t){const{context:n,value:r}=await this.getSignatureStatuses([e],t);se(r.length===1);const o=r[0];return{context:n,value:o}}async getSignatureStatuses(e,t){const n=[e];t&&n.push(t);const r=await this._rpcRequest("getSignatureStatuses",n),o=B(r,Zu);if("error"in o)throw new W(o.error,"failed to get signature status");return o.result}async getTransactionCount(e){const{commitment:t,config:n}=le(e),r=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getTransactionCount",r),i=B(o,V(g()));if("error"in i)throw new W(i.error,"failed to get transaction count");return i.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getInflationGovernor",t),r=B(n,wu);if("error"in r)throw new W(r.error,"failed to get inflation");return r.result}async getInflationReward(e,t,n){const{commitment:r,config:o}=le(n),i=this._buildArgs([e.map(u=>u.toBase58())],r,void 0,{...o,epoch:t??(o==null?void 0:o.epoch)}),a=await this._rpcRequest("getInflationReward",i),c=B(a,su);if("error"in c)throw new W(c.error,"failed to get inflation reward");return c.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=B(e,ku);if("error"in t)throw new W(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:n}=le(e),r=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getEpochInfo",r),i=B(o,Iu);if("error"in i)throw new W(i.error,"failed to get epoch info");return i.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=B(e,Eu);if("error"in t)throw new W(t.error,"failed to get epoch schedule");const n=t.result;return new jc(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=B(e,Au);if("error"in t)throw new W(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const n=this._buildArgs([e],t),r=await this._rpcRequest("getMinimumBalanceForRentExemption",n),o=B(r,Ju);return"error"in o?(console.warn("Unable to fetch minimum balance for rent exemption"),0):o.result}async getRecentBlockhashAndContext(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getRecentBlockhash",t),r=B(n,al);if("error"in r)throw new W(r.error,"failed to get recent blockhash");return r.result}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),n=B(t,dl);if("error"in n)throw new W(n.error,"failed to get recent performance samples");return n.result}async getFeeCalculatorForBlockhash(e,t){const n=this._buildArgs([e],t),r=await this._rpcRequest("getFeeCalculatorForBlockhash",n),o=B(r,hl);if("error"in o)throw new W(o.error,"failed to get fee calculator");const{context:i,value:a}=o.result;return{context:i,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(e,t){const n=j(e.serialize()).toString("base64"),r=this._buildArgs([n],t),o=await this._rpcRequest("getFeeForMessage",r),i=B(o,Se(T(g())));if("error"in i)throw new W(i.error,"failed to get fee for message");if(i.result===null)throw new Error("invalid blockhash");return i.result}async getRecentPrioritizationFees(e){var i;const t=(i=e==null?void 0:e.lockedWritableAccounts)==null?void 0:i.map(a=>a.toBase58()),n=t!=null&&t.length?[t]:[],r=await this._rpcRequest("getRecentPrioritizationFees",n),o=B(r,Su);if("error"in o)throw new W(o.error,"failed to get recent prioritization fees");return o.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:n}=le(e),r=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getLatestBlockhash",r),i=B(o,cl);if("error"in i)throw new W(i.error,"failed to get latest blockhash");return i.result}async isBlockhashValid(e,t){const{commitment:n,config:r}=le(t),o=this._buildArgs([e],n,void 0,r),i=await this._rpcRequest("isBlockhashValid",o),a=B(i,ul);if("error"in a)throw new W(a.error,"failed to determine if the blockhash `"+e+"`is valid");return a.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=B(e,V(hu));if("error"in t)throw new W(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=B(e,V(A()));if("error"in t)throw new W(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:n,config:r}=le(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,r),i=await this._rpcRequest("getBlock",o);try{switch(r==null?void 0:r.transactionDetails){case"accounts":{const a=B(i,nl);if("error"in a)throw a.error;return a.result}case"none":{const a=B(i,tl);if("error"in a)throw a.error;return a.result}default:{const a=B(i,el);if("error"in a)throw a.error;const{result:c}=a;return c?{...c,transactions:c.transactions.map(({transaction:u,meta:l,version:h})=>({meta:l,transaction:{...u,message:ar(h,u.message)},version:h}))}:null}}}catch(a){throw new W(a,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:n,config:r}=le(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",r),i=await this._rpcRequest("getBlock",o);try{switch(r==null?void 0:r.transactionDetails){case"accounts":{const a=B(i,sl);if("error"in a)throw a.error;return a.result}case"none":{const a=B(i,ol);if("error"in a)throw a.error;return a.result}default:{const a=B(i,rl);if("error"in a)throw a.error;return a.result}}}catch(a){throw new W(a,"failed to get block")}}async getBlockProduction(e){let t,n;if(typeof e=="string")n=e;else if(e){const{commitment:a,...c}=e;n=a,t=c}const r=this._buildArgs([],n,"base64",t),o=await this._rpcRequest("getBlockProduction",r),i=B(o,pu);if("error"in i)throw new W(i.error,"failed to get block production information");return i.result}async getTransaction(e,t){const{commitment:n,config:r}=le(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,r),i=await this._rpcRequest("getTransaction",o),a=B(i,cr);if("error"in a)throw new W(a.error,"failed to get transaction");const c=a.result;return c&&{...c,transaction:{...c.transaction,message:ar(c.version,c.transaction.message)}}}async getParsedTransaction(e,t){const{commitment:n,config:r}=le(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",r),i=await this._rpcRequest("getTransaction",o),a=B(i,En);if("error"in a)throw new W(a.error,"failed to get transaction");return a.result}async getParsedTransactions(e,t){const{commitment:n,config:r}=le(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,"jsonParsed",r)}));return(await this._rpcBatchRequest(o)).map(c=>{const u=B(c,En);if("error"in u)throw new W(u.error,"failed to get transactions");return u.result})}async getTransactions(e,t){const{commitment:n,config:r}=le(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,void 0,r)}));return(await this._rpcBatchRequest(o)).map(c=>{const u=B(c,cr);if("error"in u)throw new W(u.error,"failed to get transactions");const l=u.result;return l&&{...l,transaction:{...l.transaction,message:ar(l.version,l.transaction.message)}}})}async getConfirmedBlock(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),r=await this._rpcRequest("getConfirmedBlock",n),o=B(r,il);if("error"in o)throw new W(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");const a={...i,transactions:i.transactions.map(({transaction:c,meta:u})=>{const l=new lt(c.message);return{meta:u,transaction:{...c,message:l}}})};return{...a,transactions:a.transactions.map(({transaction:c,meta:u})=>({meta:u,transaction:ce.populate(c.message,c.signatures)}))}}async getBlocks(e,t,n){const r=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],n),o=await this._rpcRequest("getBlocks",r),i=B(o,V(P(g())));if("error"in i)throw new W(i.error,"failed to get blocks");return i.result}async getBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),r=await this._rpcRequest("getBlock",n),o=B(r,Es);if("error"in o)throw new W(o.error,"failed to get block");const i=o.result;if(!i)throw new Error("Block "+e+" not found");return i}async getConfirmedBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),r=await this._rpcRequest("getConfirmedBlock",n),o=B(r,Es);if("error"in o)throw new W(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");return i}async getConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),r=await this._rpcRequest("getConfirmedTransaction",n),o=B(r,cr);if("error"in o)throw new W(o.error,"failed to get transaction");const i=o.result;if(!i)return i;const a=new lt(i.transaction.message),c=i.transaction.signatures;return{...i,transaction:ce.populate(a,c)}}async getParsedConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),r=await this._rpcRequest("getConfirmedTransaction",n),o=B(r,En);if("error"in o)throw new W(o.error,"failed to get confirmed transaction");return o.result}async getParsedConfirmedTransactions(e,t){const n=e.map(i=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([i],t,"jsonParsed")}));return(await this._rpcBatchRequest(n)).map(i=>{const a=B(i,En);if("error"in a)throw new W(a.error,"failed to get confirmed transactions");return a.result})}async getConfirmedSignaturesForAddress(e,t,n){let r={},o=await this.getFirstAvailableBlock();for(;!("until"in r)&&(t--,!(t<=0||t<o));)try{const c=await this.getConfirmedBlockSignatures(t,"finalized");c.signatures.length>0&&(r.until=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}let i=await this.getSlot("finalized");for(;!("before"in r)&&(n++,!(n>i));)try{const c=await this.getConfirmedBlockSignatures(n);c.signatures.length>0&&(r.before=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}return(await this.getConfirmedSignaturesForAddress2(e,r)).map(c=>c.signature)}async getConfirmedSignaturesForAddress2(e,t,n){const r=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=await this._rpcRequest("getConfirmedSignaturesForAddress2",r),i=B(o,Nu);if("error"in i)throw new W(i.error,"failed to get confirmed signatures for address");return i.result}async getSignaturesForAddress(e,t,n){const r=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=await this._rpcRequest("getSignaturesForAddress",r),i=B(o,zu);if("error"in i)throw new W(i.error,"failed to get signatures for address");return i.result}async getAddressLookupTable(e,t){const{context:n,value:r}=await this.getAccountInfoAndContext(e,t);let o=null;return r!==null&&(o=new ws({key:e,state:ws.deserialize(r.data)})),{context:n,value:o}}async getNonceAndContext(e,t){const{context:n,value:r}=await this.getAccountInfoAndContext(e,t);let o=null;return r!==null&&(o=Kr.fromAccountData(r.data)),{context:n,value:o}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+n)})}async requestAirdrop(e,t){const n=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),r=B(n,fl);if("error"in r)throw new W(r.error,`airdrop to ${e.toBase58()} failed`);return r.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await Tt(100);const n=Date.now()-this._blockhashInfo.lastFetch>=eu;if(this._blockhashInfo.latestBlockhash!==null&&!n)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,n=t?t.blockhash:null;for(let r=0;r<50;r++){const o=await this.getLatestBlockhash("finalized");if(n!==o.blockhash)return this._blockhashInfo={latestBlockhash:o,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},o;await Tt(Ko/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:n}=le(e),r=this._buildArgs([],t,"base64",n),o=await this._rpcRequest("getStakeMinimumDelegation",r),i=B(o,Se(g()));if("error"in i)throw new W(i.error,"failed to get stake minimum delegation");return i.result}async simulateTransaction(e,t,n){if("message"in e){const d=e.serialize(),f=q.Buffer.from(d).toString("base64");if(Array.isArray(t)||n!==void 0)throw new Error("Invalid arguments");const m=t||{};m.encoding="base64","commitment"in m||(m.commitment=this.commitment),t&&typeof t=="object"&&"innerInstructions"in t&&(m.innerInstructions=t.innerInstructions);const E=[f,m],I=await this._rpcRequest("simulateTransaction",E),C=B(I,Ss);if("error"in C)throw new Error("failed to simulate transaction: "+C.error.message);return C.result}let r;if(e instanceof ce){let y=e;r=new ce,r.feePayer=y.feePayer,r.instructions=e.instructions,r.nonceInfo=y.nonceInfo,r.signatures=y.signatures}else r=ce.populate(e),r._message=r._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");const o=t;if(r.nonceInfo&&o)r.sign(...o);else{let y=this._disableBlockhashCaching;for(;;){const d=await this._blockhashWithExpiryBlockHeight(y);if(r.lastValidBlockHeight=d.lastValidBlockHeight,r.recentBlockhash=d.blockhash,!o)break;if(r.sign(...o),!r.signature)throw new Error("!signature");const f=r.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(f)&&!this._blockhashInfo.transactionSignatures.includes(f)){this._blockhashInfo.simulatedSignatures.push(f);break}else y=!0}}const i=r._compile(),a=i.serialize(),u=r._serialize(a).toString("base64"),l={encoding:"base64",commitment:this.commitment};if(n){const y=(Array.isArray(n)?n:i.nonProgramIds()).map(d=>d.toBase58());l.accounts={encoding:"base64",addresses:y}}o&&(l.sigVerify=!0),t&&typeof t=="object"&&"innerInstructions"in t&&(l.innerInstructions=t.innerInstructions);const h=[u,l],w=await this._rpcRequest("simulateTransaction",h),p=B(w,Ss);if("error"in p){let y;if("data"in p.error&&(y=p.error.data.logs,y&&Array.isArray(y))){const d=`
    `,f=d+y.join(d);console.error(p.error.message,f)}throw new On({action:"simulate",signature:"",transactionMessage:p.error.message,logs:y})}return p.result}async sendTransaction(e,t,n){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const i=e.serialize();return await this.sendRawTransaction(i,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");const r=t;if(e.nonceInfo)e.sign(...r);else{let i=this._disableBlockhashCaching;for(;;){const a=await this._blockhashWithExpiryBlockHeight(i);if(e.lastValidBlockHeight=a.lastValidBlockHeight,e.recentBlockhash=a.blockhash,e.sign(...r),!e.signature)throw new Error("!signature");const c=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))i=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}const o=e.serialize();return await this.sendRawTransaction(o,n)}async sendRawTransaction(e,t){const n=j(e).toString("base64");return await this.sendEncodedTransaction(n,t)}async sendEncodedTransaction(e,t){const n={encoding:"base64"},r=t&&t.skipPreflight,o=r===!0?"processed":t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(n.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(n.minContextSlot=t.minContextSlot),r&&(n.skipPreflight=r),o&&(n.preflightCommitment=o);const i=[e,n],a=await this._rpcRequest("sendTransaction",i),c=B(a,gl);if("error"in c){let u;throw"data"in c.error&&(u=c.error.data.logs),new On({action:r?"send":"simulate",signature:"",transactionMessage:c.error.message,logs:u})}return c.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,n])=>{this._setSubscription(t,{...n,state:"pending"})})}_setSubscription(e,t){var r;const n=(r=this._subscriptionsByHash[e])==null?void 0:r.state;if(this._subscriptionsByHash[e]=t,n!==t.state){const o=this._subscriptionStateChangeCallbacksByHash[e];o&&o.forEach(i=>{try{i(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){var o;const n=this._subscriptionHashByClientSubscriptionId[e];if(n==null)return()=>{};const r=(o=this._subscriptionStateChangeCallbacksByHash)[n]||(o[n]=new Set);return r.add(t),()=>{r.delete(t),r.size===0&&delete this._subscriptionStateChangeCallbacksByHash[n]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(n){n instanceof Error&&console.log(`Error when closing socket connection: ${n.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async n=>{const r=this._subscriptionsByHash[n];if(r!==void 0)switch(r.state){case"pending":case"unsubscribed":if(r.callbacks.size===0){delete this._subscriptionsByHash[n],r.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[r.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:o,method:i}=r;try{this._setSubscription(n,{...r,state:"subscribing"});const a=await this._rpcWebSocket.call(i,o);this._setSubscription(n,{...r,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=r.callbacks,await this._updateSubscriptions()}catch(a){if(a instanceof Error&&console.error(`${i} error for argument`,o,a.message),!t())return;this._setSubscription(n,{...r,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":r.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:o,unsubscribeMethod:i}=r;if(this._subscriptionsAutoDisposedByRpc.has(o))this._subscriptionsAutoDisposedByRpc.delete(o);else{this._setSubscription(n,{...r,state:"unsubscribing"}),this._setSubscription(n,{...r,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[o])}catch(a){if(a instanceof Error&&console.error(`${i} error:`,a.message),!t())return;this._setSubscription(n,{...r,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(n,{...r,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const n=this._subscriptionCallbacksByServerSubscriptionId[e];n!==void 0&&n.forEach(r=>{try{r(...t)}catch(o){console.error(o)}})}_wsOnAccountNotification(e){const{result:t,subscription:n}=B(e,Uu);this._handleServerNotification(n,[t.value,t.context])}_makeSubscription(e,t){const n=this._nextClientSubscriptionId++,r=bs([e.method,t]),o=this._subscriptionsByHash[r];return o===void 0?this._subscriptionsByHash[r]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:o.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[n]=r,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];const i=this._subscriptionsByHash[r];se(i!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),i.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),n}onAccountChange(e,t,n){const{commitment:r,config:o}=le(n),i=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64",o);return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},i)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:n}=B(e,Wu);this._handleServerNotification(n,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,n,r){const{commitment:o,config:i}=le(n),a=this._buildArgs([e.toBase58()],o||this._commitment||"finalized","base64",i||(r?{filters:ks(r)}:void 0));return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},a)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,n){const r=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],n||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},r)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:n}=B(e,yl);this._handleServerNotification(n,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:n}=B(e,Du);this._handleServerNotification(n,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:n}=B(e,$u);this._handleServerNotification(n,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const n=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];n?await n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,n,r){const o=t||this._commitment;if(o||n||r){let i={};n&&(i.encoding=n),o&&(i.commitment=o),r&&(i=Object.assign(i,r)),e.push(i)}return e}_buildArgsAtLeastConfirmed(e,t,n,r){const o=t||this._commitment;if(o&&!["confirmed","finalized"].includes(o))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,n,r)}_wsOnSignatureNotification(e){const{result:t,subscription:n}=B(e,Mu);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,n){const r=this._buildArgs([e],n||this._commitment||"finalized"),o=this._makeSubscription({callback:(i,a)=>{if(i.type==="status"){t(i.result,a);try{this.removeSignatureListener(o)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},r);return o}onSignatureWithOptions(e,t,n){const{commitment:r,...o}={...n,commitment:n&&n.commitment||this._commitment||"finalized"},i=this._buildArgs([e],r,void 0,o),a=this._makeSubscription({callback:(c,u)=>{t(c,u);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return a}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:n}=B(e,Hu);this._handleServerNotification(n,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class cn{constructor(e){this._keypair=void 0,this._keypair=e??hs()}static generate(){return new cn(hs())}static fromSecretKey(e,t){if(e.byteLength!==64)throw new Error("bad secret key size");const n=e.slice(32,64);if(!t||!t.skipValidation){const r=e.slice(0,32),o=Tn(r);for(let i=0;i<32;i++)if(n[i]!==o[i])throw new Error("provided secretKey is invalid")}return new cn({publicKey:n,secretKey:e})}static fromSeed(e){const t=Tn(e),n=new Uint8Array(64);return n.set(e),n.set(t,32),new cn({publicKey:t,secretKey:n})}get publicKey(){return new x(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const Et=Object.freeze({CreateLookupTable:{index:0,layout:z([N("instruction"),Yt("recentSlot"),te("bumpSeed")])},FreezeLookupTable:{index:1,layout:z([N("instruction")])},ExtendLookupTable:{index:2,layout:z([N("instruction"),Yt(),Ue(X(),Bt(N(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:z([N("instruction")])},CloseLookupTable:{index:4,layout:z([N("instruction")])}});class Yl{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=N("instruction").decode(e.data);let r;for(const[o,i]of Object.entries(Et))if(i.index==n){r=o;break}if(!r)throw new Error("Invalid Instruction. Should be a LookupTable Instruction");return r}static decodeCreateLookupTable(e){this.checkProgramId(e.programId),this.checkKeysLength(e.keys,4);const{recentSlot:t}=ae(Et.CreateLookupTable,e.data);return{authority:e.keys[1].pubkey,payer:e.keys[2].pubkey,recentSlot:Number(t)}}static decodeExtendLookupTable(e){if(this.checkProgramId(e.programId),e.keys.length<2)throw new Error(`invalid instruction; found ${e.keys.length} keys, expected at least 2`);const{addresses:t}=ae(Et.ExtendLookupTable,e.data);return{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,payer:e.keys.length>2?e.keys[2].pubkey:void 0,addresses:t.map(n=>new x(n))}}static decodeCloseLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,3),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,recipient:e.keys[2].pubkey}}static decodeFreezeLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static decodeDeactivateLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(Zo.programId))throw new Error("invalid instruction; programId is not AddressLookupTable Program")}static checkKeysLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}class Zo{constructor(){}static createLookupTable(e){const[t,n]=x.findProgramAddressSync([e.authority.toBuffer(),wo(BigInt(e.recentSlot),8)],this.programId),r=Et.CreateLookupTable,o=ee(r,{recentSlot:BigInt(e.recentSlot),bumpSeed:n}),i=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:ze.programId,isSigner:!1,isWritable:!1}];return[new de({programId:this.programId,keys:i,data:o}),t]}static freezeLookupTable(e){const t=Et.FreezeLookupTable,n=ee(t),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new de({programId:this.programId,keys:r,data:n})}static extendLookupTable(e){const t=Et.ExtendLookupTable,n=ee(t,{addresses:e.addresses.map(o=>o.toBytes())}),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&r.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:ze.programId,isSigner:!1,isWritable:!1}),new de({programId:this.programId,keys:r,data:n})}static deactivateLookupTable(e){const t=Et.DeactivateLookupTable,n=ee(t),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new de({programId:this.programId,keys:r,data:n})}static closeLookupTable(e){const t=Et.CloseLookupTable,n=ee(t),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new de({programId:this.programId,keys:r,data:n})}}Zo.programId=new x("AddressLookupTab1e1111111111111111111111111");class Zl{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=te("instruction").decode(e.data);let r;for(const[o,i]of Object.entries(mt))if(i.index==n){r=o;break}if(!r)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return r}static decodeRequestUnits(e){this.checkProgramId(e.programId);const{units:t,additionalFee:n}=ae(mt.RequestUnits,e.data);return{units:t,additionalFee:n}}static decodeRequestHeapFrame(e){this.checkProgramId(e.programId);const{bytes:t}=ae(mt.RequestHeapFrame,e.data);return{bytes:t}}static decodeSetComputeUnitLimit(e){this.checkProgramId(e.programId);const{units:t}=ae(mt.SetComputeUnitLimit,e.data);return{units:t}}static decodeSetComputeUnitPrice(e){this.checkProgramId(e.programId);const{microLamports:t}=ae(mt.SetComputeUnitPrice,e.data);return{microLamports:t}}static checkProgramId(e){if(!e.equals(Jo.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const mt=Object.freeze({RequestUnits:{index:0,layout:z([te("instruction"),N("units"),N("additionalFee")])},RequestHeapFrame:{index:1,layout:z([te("instruction"),N("bytes")])},SetComputeUnitLimit:{index:2,layout:z([te("instruction"),N("units")])},SetComputeUnitPrice:{index:3,layout:z([te("instruction"),Yt("microLamports")])}});class Jo{constructor(){}static requestUnits(e){const t=mt.RequestUnits,n=ee(t,e);return new de({keys:[],programId:this.programId,data:n})}static requestHeapFrame(e){const t=mt.RequestHeapFrame,n=ee(t,e);return new de({keys:[],programId:this.programId,data:n})}static setComputeUnitLimit(e){const t=mt.SetComputeUnitLimit,n=ee(t,e);return new de({keys:[],programId:this.programId,data:n})}static setComputeUnitPrice(e){const t=mt.SetComputeUnitPrice,n=ee(t,{microLamports:BigInt(e.microLamports)});return new de({keys:[],programId:this.programId,data:n})}}Jo.programId=new x("ComputeBudget111111111111111111111111111111");const As=64,_s=32,Bs=64,xs=z([te("numSignatures"),te("padding"),et("signatureOffset"),et("signatureInstructionIndex"),et("publicKeyOffset"),et("publicKeyInstructionIndex"),et("messageDataOffset"),et("messageDataSize"),et("messageInstructionIndex")]);class qr{constructor(){}static createInstructionWithPublicKey(e){const{publicKey:t,message:n,signature:r,instructionIndex:o}=e;se(t.length===_s,`Public Key must be ${_s} bytes but received ${t.length} bytes`),se(r.length===Bs,`Signature must be ${Bs} bytes but received ${r.length} bytes`);const i=xs.span,a=i+t.length,c=a+r.length,u=1,l=q.Buffer.alloc(c+n.length),h=o??65535;return xs.encode({numSignatures:u,padding:0,signatureOffset:a,signatureInstructionIndex:h,publicKeyOffset:i,publicKeyInstructionIndex:h,messageDataOffset:c,messageDataSize:n.length,messageInstructionIndex:h},l),l.fill(t,i),l.fill(r,a),l.fill(n,c),new de({keys:[],programId:qr.programId,data:l})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:n,instructionIndex:r}=e;se(t.length===As,`Private key must be ${As} bytes but received ${t.length} bytes`);try{const o=cn.fromSecretKey(t),i=o.publicKey.toBytes(),a=zr(n,o.secretKey);return this.createInstructionWithPublicKey({publicKey:i,message:n,signature:a,instructionIndex:r})}catch(o){throw new Error(`Error creating instruction; ${o}`)}}}qr.programId=new x("Ed25519SigVerify111111111111111111111111111");const ml=(s,e)=>{const t=$n.sign(s,e);return[t.toCompactRawBytes(),t.recovery]};$n.utils.isValidPrivateKey;const wl=$n.getPublicKey,vs=32,ur=20,Rs=64,kl=11,lr=z([te("numSignatures"),et("signatureOffset"),te("signatureInstructionIndex"),et("ethAddressOffset"),te("ethAddressInstructionIndex"),et("messageDataOffset"),et("messageDataSize"),te("messageInstructionIndex"),ge(20,"ethAddress"),ge(64,"signature"),te("recoveryId")]);class un{constructor(){}static publicKeyToEthAddress(e){se(e.length===Rs,`Public key must be ${Rs} bytes but received ${e.length} bytes`);try{return q.Buffer.from(Qr(j(e))).slice(-ur)}catch(t){throw new Error(`Error constructing Ethereum address: ${t}`)}}static createInstructionWithPublicKey(e){const{publicKey:t,message:n,signature:r,recoveryId:o,instructionIndex:i}=e;return un.createInstructionWithEthAddress({ethAddress:un.publicKeyToEthAddress(t),message:n,signature:r,recoveryId:o,instructionIndex:i})}static createInstructionWithEthAddress(e){const{ethAddress:t,message:n,signature:r,recoveryId:o,instructionIndex:i=0}=e;let a;typeof t=="string"?t.startsWith("0x")?a=q.Buffer.from(t.substr(2),"hex"):a=q.Buffer.from(t,"hex"):a=t,se(a.length===ur,`Address must be ${ur} bytes but received ${a.length} bytes`);const c=1+kl,u=c,l=c+a.length,h=l+r.length+1,w=1,p=q.Buffer.alloc(lr.span+n.length);return lr.encode({numSignatures:w,signatureOffset:l,signatureInstructionIndex:i,ethAddressOffset:u,ethAddressInstructionIndex:i,messageDataOffset:h,messageDataSize:n.length,messageInstructionIndex:i,signature:j(r),ethAddress:j(a),recoveryId:o},p),p.fill(j(n),lr.span),new de({keys:[],programId:un.programId,data:p})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:n,instructionIndex:r}=e;se(t.length===vs,`Private key must be ${vs} bytes but received ${t.length} bytes`);try{const o=j(t),i=wl(o,!1).slice(1),a=q.Buffer.from(Qr(j(n))),[c,u]=ml(a,o);return this.createInstructionWithPublicKey({publicKey:i,message:n,signature:c,recoveryId:u,instructionIndex:r})}catch(o){throw new Error(`Error creating instruction; ${o}`)}}}un.programId=new x("KeccakSecp256k11111111111111111111111111111");var Xo;const Sl=new x("StakeConfig11111111111111111111111111111111");class Il{constructor(e,t){this.staker=void 0,this.withdrawer=void 0,this.staker=e,this.withdrawer=t}}class jn{constructor(e,t,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=n}}Xo=jn;jn.default=new Xo(0,0,x.default);class Jl{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=N("instruction").decode(e.data);let r;for(const[o,i]of Object.entries(Ce))if(i.index==n){r=o;break}if(!r)throw new Error("Instruction type incorrect; not a StakeInstruction");return r}static decodeInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t,lockup:n}=ae(Ce.Initialize,e.data);return{stakePubkey:e.keys[0].pubkey,authorized:new Il(new x(t.staker),new x(t.withdrawer)),lockup:new jn(n.unixTimestamp,n.epoch,new x(n.custodian))}}static decodeDelegate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,6),ae(Ce.Delegate,e.data),{stakePubkey:e.keys[0].pubkey,votePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[5].pubkey}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,stakeAuthorizationType:n}=ae(Ce.Authorize,e.data),r={stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new x(t),stakeAuthorizationType:{index:n}};return e.keys.length>3&&(r.custodianPubkey=e.keys[3].pubkey),r}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{newAuthorized:t,stakeAuthorizationType:n,authoritySeed:r,authorityOwner:o}=ae(Ce.AuthorizeWithSeed,e.data),i={stakePubkey:e.keys[0].pubkey,authorityBase:e.keys[1].pubkey,authoritySeed:r,authorityOwner:new x(o),newAuthorizedPubkey:new x(t),stakeAuthorizationType:{index:n}};return e.keys.length>3&&(i.custodianPubkey=e.keys[3].pubkey),i}static decodeSplit(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=ae(Ce.Split,e.data);return{stakePubkey:e.keys[0].pubkey,splitStakePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[2].pubkey,lamports:t}}static decodeMerge(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),ae(Ce.Merge,e.data),{stakePubkey:e.keys[0].pubkey,sourceStakePubKey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=ae(Ce.Withdraw,e.data),n={stakePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t};return e.keys.length>5&&(n.custodianPubkey=e.keys[5].pubkey),n}static decodeDeactivate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),ae(Ce.Deactivate,e.data),{stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static checkProgramId(e){if(!e.equals($r.programId))throw new Error("invalid instruction; programId is not StakeProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const Ce=Object.freeze({Initialize:{index:0,layout:z([N("instruction"),Pc(),Tc()])},Authorize:{index:1,layout:z([N("instruction"),X("newAuthorized"),N("stakeAuthorizationType")])},Delegate:{index:2,layout:z([N("instruction")])},Split:{index:3,layout:z([N("instruction"),Ye("lamports")])},Withdraw:{index:4,layout:z([N("instruction"),Ye("lamports")])},Deactivate:{index:5,layout:z([N("instruction")])},Merge:{index:7,layout:z([N("instruction")])},AuthorizeWithSeed:{index:8,layout:z([N("instruction"),X("newAuthorized"),N("stakeAuthorizationType"),Ct("authoritySeed"),X("authorityOwner")])}}),Xl=Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class $r{constructor(){}static initialize(e){const{stakePubkey:t,authorized:n,lockup:r}=e,o=r||jn.default,i=Ce.Initialize,a=ee(i,{authorized:{staker:j(n.staker.toBuffer()),withdrawer:j(n.withdrawer.toBuffer())},lockup:{unixTimestamp:o.unixTimestamp,epoch:o.epoch,custodian:j(o.custodian.toBuffer())}}),c={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:hn,isSigner:!1,isWritable:!1}],programId:this.programId,data:a};return new de(c)}static createAccountWithSeed(e){const t=new ce;t.add(ze.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:n,authorized:r,lockup:o}=e;return t.add(this.initialize({stakePubkey:n,authorized:r,lockup:o}))}static createAccount(e){const t=new ce;t.add(ze.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:n,authorized:r,lockup:o}=e;return t.add(this.initialize({stakePubkey:n,authorized:r,lockup:o}))}static delegate(e){const{stakePubkey:t,authorizedPubkey:n,votePubkey:r}=e,o=Ce.Delegate,i=ee(o);return new ce().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:pt,isSigner:!1,isWritable:!1},{pubkey:or,isSigner:!1,isWritable:!1},{pubkey:Sl,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static authorize(e){const{stakePubkey:t,authorizedPubkey:n,newAuthorizedPubkey:r,stakeAuthorizationType:o,custodianPubkey:i}=e,a=Ce.Authorize,c=ee(a,{newAuthorized:j(r.toBuffer()),stakeAuthorizationType:o.index}),u=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:pt,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return i&&u.push({pubkey:i,isSigner:!0,isWritable:!1}),new ce().add({keys:u,programId:this.programId,data:c})}static authorizeWithSeed(e){const{stakePubkey:t,authorityBase:n,authoritySeed:r,authorityOwner:o,newAuthorizedPubkey:i,stakeAuthorizationType:a,custodianPubkey:c}=e,u=Ce.AuthorizeWithSeed,l=ee(u,{newAuthorized:j(i.toBuffer()),stakeAuthorizationType:a.index,authoritySeed:r,authorityOwner:j(o.toBuffer())}),h=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:pt,isSigner:!1,isWritable:!1}];return c&&h.push({pubkey:c,isSigner:!0,isWritable:!1}),new ce().add({keys:h,programId:this.programId,data:l})}static splitInstruction(e){const{stakePubkey:t,authorizedPubkey:n,splitStakePubkey:r,lamports:o}=e,i=Ce.Split,a=ee(i,{lamports:o});return new de({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:a})}static split(e,t){const n=new ce;return n.add(ze.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:t,space:this.space,programId:this.programId})),n.add(this.splitInstruction(e))}static splitWithSeed(e,t){const{stakePubkey:n,authorizedPubkey:r,splitStakePubkey:o,basePubkey:i,seed:a,lamports:c}=e,u=new ce;return u.add(ze.allocate({accountPubkey:o,basePubkey:i,seed:a,space:this.space,programId:this.programId})),t&&t>0&&u.add(ze.transfer({fromPubkey:e.authorizedPubkey,toPubkey:o,lamports:t})),u.add(this.splitInstruction({stakePubkey:n,authorizedPubkey:r,splitStakePubkey:o,lamports:c}))}static merge(e){const{stakePubkey:t,sourceStakePubKey:n,authorizedPubkey:r}=e,o=Ce.Merge,i=ee(o);return new ce().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:pt,isSigner:!1,isWritable:!1},{pubkey:or,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static withdraw(e){const{stakePubkey:t,authorizedPubkey:n,toPubkey:r,lamports:o,custodianPubkey:i}=e,a=Ce.Withdraw,c=ee(a,{lamports:o}),u=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:pt,isSigner:!1,isWritable:!1},{pubkey:or,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return i&&u.push({pubkey:i,isSigner:!0,isWritable:!1}),new ce().add({keys:u,programId:this.programId,data:c})}static deactivate(e){const{stakePubkey:t,authorizedPubkey:n}=e,r=Ce.Deactivate,o=ee(r);return new ce().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:pt,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}}$r.programId=new x("Stake11111111111111111111111111111111111111");$r.space=200;class El{constructor(e,t,n,r){this.nodePubkey=void 0,this.authorizedVoter=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.nodePubkey=e,this.authorizedVoter=t,this.authorizedWithdrawer=n,this.commission=r}}class Ql{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=N("instruction").decode(e.data);let r;for(const[o,i]of Object.entries(at))if(i.index==n){r=o;break}if(!r)throw new Error("Instruction type incorrect; not a VoteInstruction");return r}static decodeInitializeAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,4);const{voteInit:t}=ae(at.InitializeAccount,e.data);return{votePubkey:e.keys[0].pubkey,nodePubkey:e.keys[3].pubkey,voteInit:new El(new x(t.nodePubkey),new x(t.authorizedVoter),new x(t.authorizedWithdrawer),t.commission)}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,voteAuthorizationType:n}=ae(at.Authorize,e.data);return{votePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new x(t),voteAuthorizationType:{index:n}}}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:t,currentAuthorityDerivedKeySeed:n,newAuthorized:r,voteAuthorizationType:o}}=ae(at.AuthorizeWithSeed,e.data);return{currentAuthorityDerivedKeyBasePubkey:e.keys[2].pubkey,currentAuthorityDerivedKeyOwnerPubkey:new x(t),currentAuthorityDerivedKeySeed:n,newAuthorizedPubkey:new x(r),voteAuthorizationType:{index:o},votePubkey:e.keys[0].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=ae(at.Withdraw,e.data);return{votePubkey:e.keys[0].pubkey,authorizedWithdrawerPubkey:e.keys[2].pubkey,lamports:t,toPubkey:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(wn.programId))throw new Error("invalid instruction; programId is not VoteProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const at=Object.freeze({InitializeAccount:{index:0,layout:z([N("instruction"),Lc()])},Authorize:{index:1,layout:z([N("instruction"),X("newAuthorized"),N("voteAuthorizationType")])},Withdraw:{index:3,layout:z([N("instruction"),Ye("lamports")])},UpdateValidatorIdentity:{index:4,layout:z([N("instruction")])},AuthorizeWithSeed:{index:10,layout:z([N("instruction"),Cc()])}}),ed=Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class wn{constructor(){}static initializeAccount(e){const{votePubkey:t,nodePubkey:n,voteInit:r}=e,o=at.InitializeAccount,i=ee(o,{voteInit:{nodePubkey:j(r.nodePubkey.toBuffer()),authorizedVoter:j(r.authorizedVoter.toBuffer()),authorizedWithdrawer:j(r.authorizedWithdrawer.toBuffer()),commission:r.commission}}),a={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:hn,isSigner:!1,isWritable:!1},{pubkey:pt,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i};return new de(a)}static createAccount(e){const t=new ce;return t.add(ze.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){const{votePubkey:t,authorizedPubkey:n,newAuthorizedPubkey:r,voteAuthorizationType:o}=e,i=at.Authorize,a=ee(i,{newAuthorized:j(r.toBuffer()),voteAuthorizationType:o.index}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:pt,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return new ce().add({keys:c,programId:this.programId,data:a})}static authorizeWithSeed(e){const{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:n,currentAuthorityDerivedKeySeed:r,newAuthorizedPubkey:o,voteAuthorizationType:i,votePubkey:a}=e,c=at.AuthorizeWithSeed,u=ee(c,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:j(n.toBuffer()),currentAuthorityDerivedKeySeed:r,newAuthorized:j(o.toBuffer()),voteAuthorizationType:i.index}}),l=[{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:pt,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return new ce().add({keys:l,programId:this.programId,data:u})}static withdraw(e){const{votePubkey:t,authorizedWithdrawerPubkey:n,lamports:r,toPubkey:o}=e,i=at.Withdraw,a=ee(i,{lamports:r}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return new ce().add({keys:c,programId:this.programId,data:a})}static safeWithdraw(e,t,n){if(e.lamports>t-n)throw new Error("Withdraw will leave vote account with insufficient funds.");return wn.withdraw(e)}static updateValidatorIdentity(e){const{votePubkey:t,authorizedWithdrawerPubkey:n,nodePubkey:r}=e,o=at.UpdateValidatorIdentity,i=ee(o),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return new ce().add({keys:a,programId:this.programId,data:i})}}wn.programId=new x("Vote111111111111111111111111111111111111111");wn.space=3762;const Al=new x("Va1idator1nfo111111111111111111111111111111"),_l=S({name:A(),website:$(A()),details:$(A()),iconUrl:$(A()),keybaseUsername:$(A())});class Qo{constructor(e,t){this.key=void 0,this.info=void 0,this.key=e,this.info=t}static fromConfigData(e){let t=[...e];if(He(t)!==2)return null;const r=[];for(let o=0;o<2;o++){const i=new x(Ve(t,0,wt)),a=it(t)===1;r.push({publicKey:i,isSigner:a})}if(r[0].publicKey.equals(Al)&&r[1].isSigner){const o=Ct().decode(q.Buffer.from(t)),i=JSON.parse(o);return ko(i,_l),new Qo(r[1].publicKey,i)}return null}}const td=new x("Vote111111111111111111111111111111111111111"),Bl=z([X("nodePubkey"),X("authorizedWithdrawer"),te("commission"),Le(),Ue(z([Le("slot"),N("confirmationCount")]),Bt(N(),-8),"votes"),te("rootSlotValid"),Le("rootSlot"),Le(),Ue(z([Le("epoch"),X("authorizedVoter")]),Bt(N(),-8),"authorizedVoters"),z([Ue(z([X("authorizedPubkey"),Le("epochOfLastAuthorizedSwitch"),Le("targetEpoch")]),32,"buf"),Le("idx"),te("isEmpty")],"priorVoters"),Le(),Ue(z([Le("epoch"),Le("credits"),Le("prevCredits")]),Bt(N(),-8),"epochCredits"),z([Le("slot"),Le("timestamp")],"lastTimestamp")]);class ei{constructor(e){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=e.nodePubkey,this.authorizedWithdrawer=e.authorizedWithdrawer,this.commission=e.commission,this.rootSlot=e.rootSlot,this.votes=e.votes,this.authorizedVoters=e.authorizedVoters,this.priorVoters=e.priorVoters,this.epochCredits=e.epochCredits,this.lastTimestamp=e.lastTimestamp}static fromAccountData(e){const n=Bl.decode(j(e),4);let r=n.rootSlot;return n.rootSlotValid||(r=null),new ei({nodePubkey:new x(n.nodePubkey),authorizedWithdrawer:new x(n.authorizedWithdrawer),commission:n.commission,votes:n.votes,rootSlot:r,authorizedVoters:n.authorizedVoters.map(xl),priorVoters:vl(n.priorVoters),epochCredits:n.epochCredits,lastTimestamp:n.lastTimestamp})}}function xl({authorizedVoter:s,epoch:e}){return{epoch:e,authorizedVoter:new x(s)}}function Ps({authorizedPubkey:s,epochOfLastAuthorizedSwitch:e,targetEpoch:t}){return{authorizedPubkey:new x(s),epochOfLastAuthorizedSwitch:e,targetEpoch:t}}function vl({buf:s,idx:e,isEmpty:t}){return t?[]:[...s.slice(e+1).map(Ps),...s.slice(0,e).map(Ps)]}const Ts={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function nd(s,e){const t=e===!1?"http":"https";if(!s)return Ts[t].devnet;const n=Ts[t][s];if(!n)throw new Error(`Unknown ${t} cluster: ${s}`);return n}async function rd(s,e,t,n){let r,o;t&&Object.prototype.hasOwnProperty.call(t,"lastValidBlockHeight")||t&&Object.prototype.hasOwnProperty.call(t,"nonceValue")?(r=t,o=n):o=t;const i=o&&{skipPreflight:o.skipPreflight,preflightCommitment:o.preflightCommitment||o.commitment,minContextSlot:o.minContextSlot},a=await s.sendRawTransaction(e,i),c=o&&o.commitment,l=(await(r?s.confirmTransaction(r,c):s.confirmTransaction(a,c))).value;if(l.err)throw a!=null?new On({action:i!=null&&i.skipPreflight?"send":"simulate",signature:a,transactionMessage:`Status: (${JSON.stringify(l)})`}):new Error(`Raw transaction ${a} failed (${JSON.stringify(l)})`);return a}const sd=1e9;export{Ul as Account,ws as AddressLookupTableAccount,Yl as AddressLookupTableInstruction,Zo as AddressLookupTableProgram,Il as Authorized,eu as BLOCKHASH_CACHE_TIMEOUT_MS,Kl as BPF_LOADER_DEPRECATED_PROGRAM_ID,Vl as BPF_LOADER_PROGRAM_ID,jl as BpfLoader,mt as COMPUTE_BUDGET_INSTRUCTION_LAYOUTS,Zl as ComputeBudgetInstruction,Jo as ComputeBudgetProgram,Gl as Connection,qr as Ed25519Program,zl as Enum,jc as EpochSchedule,Kc as FeeCalculatorLayout,cn as Keypair,sd as LAMPORTS_PER_SOL,Et as LOOKUP_TABLE_INSTRUCTION_LAYOUTS,Zt as Loader,jn as Lockup,xc as MAX_SEED_LENGTH,lt as Message,Cn as MessageAccountKeys,Gt as MessageV0,ys as NONCE_ACCOUNT_LENGTH,Kr as NonceAccount,Nt as PACKET_DATA_SIZE,wt as PUBLIC_KEY_LENGTH,x as PublicKey,Ln as SIGNATURE_LENGTH_IN_BYTES,An as SOLANA_SCHEMA,Sl as STAKE_CONFIG_ID,Ce as STAKE_INSTRUCTION_LAYOUTS,fe as SYSTEM_INSTRUCTION_LAYOUTS,pt as SYSVAR_CLOCK_PUBKEY,Wl as SYSVAR_EPOCH_SCHEDULE_PUBKEY,Fl as SYSVAR_INSTRUCTIONS_PUBKEY,sr as SYSVAR_RECENT_BLOCKHASHES_PUBKEY,hn as SYSVAR_RENT_PUBKEY,Dl as SYSVAR_REWARDS_PUBKEY,ql as SYSVAR_SLOT_HASHES_PUBKEY,$l as SYSVAR_SLOT_HISTORY_PUBKEY,or as SYSVAR_STAKE_HISTORY_PUBKEY,un as Secp256k1Program,On as SendTransactionError,W as SolanaJSONRPCError,Ml as SolanaJSONRPCErrorCode,Xl as StakeAuthorizationLayout,Jl as StakeInstruction,$r as StakeProgram,Ro as Struct,Hl as SystemInstruction,ze as SystemProgram,ce as Transaction,To as TransactionExpiredBlockheightExceededError,on as TransactionExpiredNonceInvalidError,Lo as TransactionExpiredTimeoutError,de as TransactionInstruction,zo as TransactionMessage,It as TransactionStatus,Al as VALIDATOR_INFO_KEY,Ur as VERSION_PREFIX_MASK,td as VOTE_PROGRAM_ID,Qo as ValidatorInfo,No as VersionedMessage,Uo as VersionedTransaction,ei as VoteAccount,ed as VoteAuthorizationLayout,El as VoteInit,Ql as VoteInstruction,wn as VoteProgram,nd as clusterApiUrl,rd as sendAndConfirmRawTransaction,ps as sendAndConfirmTransaction};
